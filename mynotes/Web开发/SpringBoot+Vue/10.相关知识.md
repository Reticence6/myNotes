# vue-element-admin介绍

- 是一个后台前端解决方案，基于vue和element-ui实现
- 内置了i18国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件
- 可以快速搭建企业级中后台产品原型
- 地址：https://panjiachen.github.io/vue-element-admin-site/zh/guide/

## 项目结构

```bash
├── build                      # 构建相关
├── mock                       # 项目mock 模拟数据
├── plop-templates             # 基本模板
├── public                     # 静态资源
│   │── favicon.ico            # favicon图标
│   └── index.html             # html模板
├── src                        # 源代码
│   ├── api                    # 所有请求
│   ├── assets                 # 主题 字体等静态资源
│   ├── components             # 全局公用组件
│   ├── directive              # 全局指令
│   ├── filters                # 全局 filter
│   ├── icons                  # 项目所有 svg icons
│   ├── lang                   # 国际化 language
│   ├── layout                 # 全局 layout
│   ├── router                 # 路由
│   ├── store                  # 全局 store管理
│   ├── styles                 # 全局样式
│   ├── utils                  # 全局公用方法
│   ├── vendor                 # 公用vendor
│   ├── views                  # views 所有页面（组件）
│   ├── App.vue                # 入口页面
│   ├── main.js                # 入口文件 加载组件 初始化等
│   └── permission.js          # 权限管理
├── tests                      # 测试
├── .env.xxx                   # 环境变量配置
├── .eslintrc.js               # eslint 配置项
├── .babelrc                   # babel-loader 配置
├── .travis.yml                # 自动化CI配置
├── vue.config.js              # vue-cli 配置
├── postcss.config.js          # postcss 配置
└── package.json               # package.json
```

## 安装和使用

安装和使用请访问页面中的文档

# JWT跨域认证

## Session认证

互联网服务离不开用户认证，一般流程如下：

- 用户向服务器发送用户名和密码
- 服务器验证通过后，在当前对话（session）里保存相关数据，比如用户角色、登录时间等
- 服务器向用户返回一个session_id，写入用户的Cookie
- 用户随后的每一次请求，都会通过Cookie，将session_id传回服务器
- 服务器收到session_id，找到前期保存的数据，由此得知用户的身份

### 特点

session认证的方式应用非常普遍，但也存在一些问题：扩展性不好；若是服务器集群、或者是跨域的服务导向架构，就要求session数据共享，每台服务器都能读取session，一般有两种解决方案：

- session数据持久化，写入数据库或别的持久层
  - 各种服务收到请求后，都向持久层请求数据
  - 优点是架构清晰，缺点是工程量较大
- 服务器不再保存session数据，所有数据都保存在客户端，每次请求都发回服务器
  - Token认证就是这种方案的一个代表

## Token认证

Token是在服务端产生的一串字符串，是客户端访问资源接口API时所需要的资源凭证，流程如下：

- 客户端使用用户名和密码请求登录，服务端收到请求，去验证用户名与密码
- 验证成功后，服务端会签发一个token并把这个token发送给客户端
- 客户端收到token以后，将其存储起来，如放在cookie或localStorage中
- 客户端每次向服务端请求资源的时候需要带着服务端签发的token
- 服务端收到请求，然后验证客户端请求中的token，如果验证成功，就向客户端返回请求的数据

### 特点

- 基于token的用户认证是一种服务端无状态的认证方式，服务端不用存放token数据
- 用解析token的计算时间换取session的存储空间，从而减轻服务器的压力，减少频繁的查询数据库
- token完全由应用管理，所以可以避开同源策略

## JWT

- JSON Web Token是一个token的具体实现方式，是目前最流行的跨域认证解决方案
- 原理：服务器认证以后，生成一个JSON对象，发回给用户，如：

```json
{
	"姓名": "张三",
	"角色": "管理员",
	"到期时间": "2025年6月1日0点0分"
}
```

- 用户与服务端通信的时候，都要发回这个JSON对象。服务器完全只靠这个对象认定用户身份
- 为防止用户篡改数据，服务器在生成这个对象的时候，会加上签名

### 组成

由三部分组成：

- Header 头部
- Payload 负载
- Signature 签名

三部分最终组合为完整的字符串，中间使用`.`分割，如：Header.Payload.Signature

#### Header

- 头部是一个JSON对象，描述JWT的元数据

```JSON
{
	"alg": "HS256",
	"typ": "JWT"
}
```

- alg属性表示签名的算法，默认是HMAC SHA256（写成HS256）
- typ属性表示这个令牌token的类型，JWT令牌统一写为JWT
- 最后，将上面的JSON对象使用Base64URL算法转成字符串

#### Payload

- Payload部分也是一个JSON对象，用来存放实际需要传递的数据，JWT规定了7个官方字段供选用：
  - iss (issuer): 签发人
  - exp (expiration time): 过期时间
  - aud (audience): 受众
  - nbf (Not Before ): 生效时间
  - iat (Issued At): 签发时间
  - jti (JWT ID): 编号
- 注意，JWT默认不加密，任何人都能读到，所以不要把秘密信息放在这个部分
- 这个JSON对象也要使用Base64URL算法转成字符串

#### Signature

- Signature部分是对前两部分的签名，防止数据篡改
- 首先，需要指定一个密钥secret，这个密钥只有服务器才知道，不能泄漏给用户
- 然后，使用Header里指定的签名算法（默认是HMAC SHA256），按照下面的公式产生签名

```sh
HMACSHA256(
	base64urlEncode(header) + "." +
	base64urlEncode(payload),
	secret)
```

### 特点

- 客户端收到服务器返回的JWT，可以存储在Cookie里，也可以存储在localStorage
- 客户端每次与服务器通信，都要带上这个JWT，可以把它放在Cookie里自动发送，但是这样不能跨域
- 更好的做法是放在HTTP请求的头信息 ’Authorization‘ 字段里，单独发送

### Java的实现

加入依赖：

```xml
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt</artifactId>
	<version>0.9.1</version>
</dependency>
```

生成Token：

```java
//7天过期
private static Long expire = 604800;
//32位秘钥
private static String secret = "abcdefghiabcdfghiabcdfghiabcdfghiabcdfghi";

//生成token
public static String generateToken(String username){
    Date now = new Date();
    Date expiration = new Date(now.getTime() + 1000 * expire);
    return Jwts.builder()
        .setHeaderParam("type", "JWT")
        .setSubject(username)
        .setIssuedAt(now)
        .setExpiration(expiration)
        .signWith(SignatureAlgorithm.HS512, secret)
        .compact();
}
```

解析Token：

```java
//解析token
public static Claims getClaimsByToken(String token){
    return Jwts.parser()
        .setSigningKey(secret)
        .parseClaimsJws(token)
        .getBody();
}
```

