资料：https://heuqqdmbyk.feishu.cn/wiki/MQ95wDTtji6ob6kiRkyc9jamnwg

![image-20251207215838458](./images/image-20251207215838458.png)

# Maven

Maven是管理和构建Java项目的工具，基于项目对象模型POM的概念，通过一小段描述信息来管理项目的构建，是apache旗下的一个开源项目

作用：方便快捷地依赖管理、标准化的项目构建、统一的项目结构

## Maven基础



![image-20251107170332035](./images/image-20251107170332035.png)

### Maven坐标

- 定义
  - 坐标指的是资源（jar）的唯一标识，通过该坐标可以唯一定位资源位置
  - 使用坐标来定义项目或引入项目中需要的依赖
- 组成
  - groupId：定义当前Maven项目隶属组织名称（通常是域名反写）
  - artifactId：定义当前Maven项目名称（通常是模块名称）
  - version：定义当前项目版本号
    - SNAPSHOT：功能不稳定，尚处于开发中的版本，即快照版本
    - RELEASE：功能趋于稳定，当前更新停止，可以用于发行的版本

### 导入Maven项目

- 方式一： File -> Project Structure -> Modules -> Import Module -> 选择maven项目的pom.xml
- 方式二：Maven面板 -> + -> 选择maven项目的pom.xml

- 排除依赖：在dependency中使用exclusions标签

### 生命周期

对所有的Maven 项目构建过程进行抽象和统一

Maven中有三套相互独立的生命周期

- clean：清理工作
  - 主要关注：clean：移除上一次构建生成的文件
- default：核心工作，如编译、测试、打包、安装、部署等
  - 主要关注：
  - compile：编译项目源代码
  - test：使用合适的单元测试框架运行测试
  - package：将编译后的文件打包
  - install：安装项目到本地仓库
- site：生成报告、发布站点等
- 在同一套生命周期中，当运行后面的阶段时，前面的阶段都运行

## 单元测试

- 测试阶段：单元测试、集成测试、系统测试、验收测试
- 单元测试：针对最小的功能单元（方法），编写测试代码对其正确性进行测试

### JUnit

- 最流行的测试框架之一

- 测试类名规范：XxxTest

- JUnit单元测试的方法必须声明为：public void

- 断言

  - 用来帮忙确定被测试的方法是否按照预期的效果正常工作
  - Assertions.assertXxxx()

  | 断言方法                                                     | 描述                                     |
  | ------------------------------------------------------------ | ---------------------------------------- |
  | `Assertions.assertEquals(Object exp, Object act, String msg)` | 检查两个值是否相等，不相等就报错。       |
  | `Assertions.assertNotEquals(Object unexp, Object act, String msg)` | 检查两个值是否不相等，相等就报错。       |
  | `Assertions.assertNull(Object act, String msg)`              | 检查对象是否为null，不为null，就报错。   |
  | `Assertions.assertNotNull(Object act, String msg)`           | 检查对象是否不为null，为null，就报错。   |
  | `Assertions.assertTrue(boolean condition, String msg)`       | 检查条件是否为true，不为true，就报错。   |
  | `Assertions.assertFalse(boolean condition, String msg)`      | 检查条件是否为false，不为false，就报错。 |
  | `Assertions.assertThrows(Class expType, Executable executable, String msg)` | 检查程序运行抛出的异常，是否符合预期。   |

  ```java
  // 断言
  @Test
  public void testGetGenderWithAssert(){
      UserService userService = new UserService();
      String gender = userService.getGender("100000200010011011");
      // 断言
      Assertions.assertEquals("男", gender,"性别获取逻辑有问题");
  }
  
  @Test
  public void testGetGenderWithAssert2(){
      UserService userService = new UserService();
      Assertions.assertThrows(IllegalArgumentException.class, () -> {
          userService.getGender(null);
      });
  }
  ```

- 常见注解

  | 注解                 | 说明                                                         | 备注                            |
  | -------------------- | ------------------------------------------------------------ | ------------------------------- |
  | `@Test`              | 测试类中的方法用它修饰才能成为测试方法，才能启动执行         | 单元测试                        |
  | `@ParameterizedTest` | 参数化测试的注解（可以让单个测试运行多次，每次运行时仅参数不同） | 用了该注解，就不需要@Test注解了 |
  | `@ValueSource`       | 参数化测试的参数来源，赋予测试方法参数                       | 与参数化测试注解配合使用        |
  | `@DisplayName`       | 指定测试类、测试方法显示的名称（默认为类名、方法名）         |                                 |
  | `@BeforeEach`        | 用来修饰一个实例方法，该方法会在**每一个**测试方法执行之前执行一次。 | 初始化资源(准备工作)            |
  | `@AfterEach`         | 用来修饰一个实例方法，该方法会在**每一个**测试方法执行之后执行一次。 | 释放资源(清理工作)              |
  | `@BeforeAll`         | 用来修饰一个静态方法，该方法会在所有测试方法之前只执行一次。 | 初始化资源(准备工作)            |
  | `@AfterAll`          | 用来修饰一个静态方法，该方法会在所有测试方法之后只执行一次。 | 释放资源(清理工作)              |

### 企业开发规范

- 原则：编写测试方法时，要尽可能覆盖业务方法中所有可能的情况（尤其是边界值）

## 依赖范围

- 依赖的jar包，默认情况下，可以在任何地方使用

- 可以通过  `<scope>...</scope>`设置其租用范围

- 作用范围：

  - 主程序范围有效，main文件夹范围内
  - 测试程序范围有效，test文件夹范围内
  - 是否参与打包运行，package指令范围内

- scope：

  | scope值         | 主程序 | 测试程序 | 打包（运行） | 范例        |
  | --------------- | ------ | -------- | ------------ | ----------- |
  | compile（默认） | Y      | Y        | Y            | log4j       |
  | test            | -      | Y        | -            | junit       |
  | provided        | Y      | Y        | -            | servlet-api |
  | runtime         | -      | Y        | Y            | jdbc驱动    |

- `del /s *.lastUpdated`

## Maven高级

### 分模块设计与开发

- 将一个大项目拆分成若干子模块，方便项目的管理维护、扩展，也方便模块间的相互引用
- 策略
  - 策略一：按照功能模块拆分，比如：公共组件、商品模块、搜索模块、购物车模块、订单模块等
  - 策略二：按层拆分，比如：公共组件、实体类、控制层、业务层、数据访问层
  - 策略三：按照功能模块+层拆分

### 继承

- 继承描述的是两个工程间的关系，与java中的继承类似，子工程可以继承父工程的配置信息，常见于依赖关系的继承

- 作用：简化依赖配置、统一管理依赖

- 实现：`<parent> ... </parent>`

- 补充：

  - jar：普通模块打包，springboot项目基本都是jar包（内嵌tomcat运行）
  - war：普通web程序打包，需要部署在外部的tomcat服务器中运行
  - pom：父工程或聚合工程，该模块不写代码，仅进行依赖管理

- 继承关系实现

  - 创建maven模块tlias-parent，该工程为父工程，设置打包方式为pom（默认为jar），并继承springboot

  ```xml
  <parent>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-parent</artifactId>
      <version>3.5.7</version>
      <!--配置父工程pom.xml的相对路径-->
      <relativePath/> <!-- lookup parent from repository -->
  </parent>
  
  <groupId>com.wjk</groupId>
  <artifactId>tlias-parent</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>pom</packaging>
  ```

  - 在子工程的pom.xml文件中，配置继承关系

  ```xml
  <parent>
      <groupId>com.wjk</groupId>
      <artifactId>tlias-parent</artifactId>
      <version>1.0-SNAPSHOT</version>
      <relativePath>../tlias-parent/pom.xml</relativePath>
  </parent>
  ```

  - 在父工程中配置各个工程共有的依赖（子工程会自动继承父工程的依赖）

<img src="./images/image-20251207204421776.png" alt="image-20251207204421776" style="zoom: 50%;" />

- 注意

  - 在子工程中，配置了继承关系后，坐标中的groupId是可以省略的，因为会自动继承父工程的
  - relativePath指定父工程的pom文件的相对位置（如果不指定，将从本地仓库/远程仓库中查找）
  - 若父子工程都配置了统一依赖的不同版本，以子工程的为准

- 版本锁定

  - 在maven中，可以在父工程的pom文件通过`<dependencyManagement>`来统一管理依赖版本
  - 在子工程中引入依赖就不需要写版本

- 自定义属性/引用属性

  ```xml
  <properties>
      <maven.compiler.source>17</maven.compiler.source>
      <maven.compiler.target>17</maven.compiler.target>
      <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
      <!--自定义属性-->
      <lombok.version>1.18.34</lombok.version>
      <spring.boot.starter.version>3.2.10</spring.boot.starter.version>
      <aliyun.sdk.version>3.17.4</aliyun.sdk.version>
      <jaxb.api.version>2.3.1</jaxb.api.version>
      <activation.version>1.1.1</activation.version>
      <jaxb.runtime.version>2.3.3</jaxb.runtime.version>
      <jjwt.version>0.9.1</jjwt.version>
  </properties>
  
  <!--直接引入依赖-->
  <dependencies>
      <dependency>
          <groupId>org.projectlombok</groupId>
          <artifactId>lombok</artifactId>
          <optional>true</optional>
          <version>${lombok.version}</version>
      </dependency>
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter</artifactId>
          <version>${spring.boot.starter.version}</version>
      </dependency>
  </dependencies>
  ```

- 两个标签的区别
  - `<dependencyManagement>`：是统一管理依赖版本，不会直接依赖，还需要在子工程中引入所需依赖（无需指定版本）
  - `<dependencies>`：是直接依赖，在父工程中配置了依赖，子工程会直接继承下来

### 聚合

- 将多个模块组织成一个整体，同时进行项目的构建

- 聚合工程

  - 一个不具有业务功能的空工程（有且仅有一个pom文件）（一般父工程也是聚合工程）

- 作用

  - 快速构建项目（无需根据依赖关系手动构建，直接在聚合工程上构建即可）

- 实现

  - maven中可以通过`<modules>`设置当前聚合工程所包含的子模块名称
  - 聚合工程所包含的模块，在构建时，会自动根据模块间的依赖关系设置构建顺序，与聚合工程中模块的配置书写位置无关

  ```xml
  <modules>
      <module>../tlias-utils</module>
      <module>../tlias-pojo</module>
      <module>../tilas-web-management</module>
  </modules>
  ```

- 继承与聚合
  - 联系
    - 继承与聚合都属于设计型模块，打包方式都为pom，常将两种关系制作到同一个pom文件中
  - 区别
    - 继承用于简化依赖配置、统一管理依赖版本，是在子工程中配置继承关系
    - 聚合用于快速构建项目，是在父工程（聚合工程）中配置聚合的模块

### 私服

- 私服

  - 一种特殊的远程仓库，是架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用来解决团队内部的资源共享与资源同步问题
  - 依赖查找顺序：本地仓库 -> 私服 -> 中央仓库
  - 一个公司有一个私服即可
  - 分为三个仓库：central-中央仓库下载的包，release、snapshot

- 上传与下载资源

  - 上传：先将包install安装到本地仓库，使用depoly上传到私服

  - 上传配置

    - settings.xml中的servers中配置：访问私服的用户名/密码

    ```xml
    <server>
        <id>maven-releases</id>
        <username>admin</username>
        <password>admin</password>
    </server>
    <server>
        <id>maven-snapshots</id>
        <username>admin</username>
        <password>admin</password>
    </server>
    ```

    - IDEA的maven工程的pom文件中配置上传的地址

    ```xml
    <distributionManagement>
        <!-- release版本的发布地址 -->
        <repository>
            <id>maven-releases</id>
            <url>http://localhost:8081/repository/maven-releases/</url>
        </repository>
        <!-- snapshot版本的发布地址 -->
        <snapshotRepository>
            <id>maven-snapshots</id>
            <url>http://localhost:8081/repository/maven-snapshots/</url>
        </snapshotRepository>
    </distributionManagement>
    ```

  - 下载配置

    - 在setting.xml的mirrors、profiles中配置

    ```xml
    <mirror>
        <id>maven-public</id>
        <mirrorOf>*</mirrorOf>
        <url>http://localhost:8081/repository/maven-public/</url>
    </mirror>
    ```

    - profiles：

    ```xml
    <profile>
        <id>allow-snapshots</id>
        <activation>
            <activeByDefault>true</activeByDefault>
        </activation>
        <repositories>
            <repository>
                <id>maven-public</id>
                <url>http://localhost:8081/repository/maven-public/</url>
                <releases>
                    <enabled>true</enabled>
                </releases>
                <snapshots>
                    <enabled>true</enabled>
                </snapshots>
            </repository>
        </repositories>
    </profile>
    ```

![image-20251207213701451](./images/image-20251207213701451.png)

# Web基础

## SpringBoot

`https://start.spring.io` 如果连接不上，可以使用：`https://start.aliyun.com`

- 起步依赖
  - spring-boot-starter-web：包含了web应用开发所需的常见依赖
  - spring-boot-starter-test：包含了单元测试所需要的常见依赖

### 配置文件

- SpringBoot项目提供了多种属性配置方法：properties、yaml、yml

- application.properties

  - key-value形式
  - 臃肿，层次结构不清晰

  ```properties
  spring.application.name=springboot-mybatis-quickstart
  
  # 配置数据库的连接信息
  spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
  spring.datasource.url=jdbc:mysql://localhost:3306/learning
  spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
  spring.datasource.username=root
  spring.datasource.password=wjk
  # 配置mybatis的日志输出
  mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
  
  # 配置XML映射文件的位置
  mybatis.mapper-locations=classpath:mapper/*.xml
  ```

- application.yaml/application.yml

  - 按层级定义

  - 简洁，以数据为中心

  - 格式：

    - 数值前必须有空格，作为分隔符
    - 使用缩进表示层级关系，缩进时不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格）
    - 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可
    - #表示注释

  - 定义对象/Map集合

    ```yaml
    User:
    	name: zhangsan
    	age: 18
    	password: 123456
    ```

  - 定义数组/List/Set集合

    ```yaml
    hobby:
    	- java
    	- game
    	- sport
    ```

  - 注意：在yml格式的配置文件中，如果配置项的值时以0开头的，值需要用单引号引起来，因为以0开头在yml中表示8进制的数据

  ```yaml
  spring:
    application:
      name: springboot-mybatis-quickstart
    # 数据库的连接信息
    datasource:
      type: com.alibaba.druid.pool.DruidDataSource
      url: jdbc:mysql://localhost:3306/learning
      driver-class-name: com.mysql.cj.jdbc.Driver
      username: root
      password: wjk
  
  # mybatis的配置信息
  mybatis:
    configuration:
      log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
    mapper-locations: classpath:mapper/*.xml
  ```

## HTTP协议

1. 请求数据格式

   - 请求行：请求数据第一行（请求方式、资源路径、协议）
   - 请求头：第二行开始，格式为key: value
   - 请求体：POST请求，存放请求参数，在请求头后有一个空行，然后才是请求体
   - GET请求大小有限制，POST的请求体中大小无限制

2. 请求数据获取

   - Web服务器对HTTP协议的请求数据进行解析，并进行了封装（HttpServletRequest），在调用Controller方法的时候传递给了该方法

   ```java
   @RequestMapping("/request")
   public String request(HttpServletRequest request){
       // 1.获取请求方式
       String method = request.getMethod(); // GET
       System.out.println("请求方式：" + method);
   
       // 2.获取请求url地址
       String url = request.getRequestURL().toString(); // http://localhost:8080/request
       System.out.println("请求url：" + url);
       String uri = request.getRequestURI(); // /request
       System.out.println("请求uri：" + uri);
   
       // 3.获取请求协议
       String protocol = request.getProtocol(); // HTTP/1.1
       System.out.println("请求协议：" + protocol);
   
       // 4.获取请求参数 - name, age
       String name = request.getParameter("name");
       String age = request.getParameter("age");
       System.out.println("name：" + name + ", age: " + age);
   
       // 5.获取请求头 - Accept部分
       String header = request.getHeader("Accept");
       System.out.println("Accept：" + header);
   
       return "OK";
   }
   ```

3. 响应数据格式

   - 响应行：第一行（协议、状态码、描述）

     - 状态码

     | 状态码范围 | 类别       | 描述                                                         |
     | ---------- | ---------- | ------------------------------------------------------------ |
     | 1xx        | 响应中     | 临时状态码，表示请求已经接收，告诉客户端应该继续请求或者如果它已经完成则忽略它。 |
     | 2xx        | 成功       | 表示请求已经被成功接收，处理已完成。                         |
     | 3xx        | 重定向     | 重定向到其他地方；让客户端再发起一次请求以完成整个处理。     |
     | 4xx        | 客户端错误 | 处理错误，责任在客户端，如请求了不存在的资源、客户端未被授权、禁止访问等。 |
     | 5xx        | 服务器错误 | 处理发生错误，责任在服务端。如：程序抛出异常等。             |

   - 响应头：第二行开始 key: value

     | 响应头字段       | 描述                                                         |
     | ---------------- | ------------------------------------------------------------ |
     | Content-Type     | 表示该响应内容的类型，例如text/html，application/json。      |
     | Content-Length   | 表示该响应内容的长度（字节数）。                             |
     | Content-Encoding | 表示该响应压缩算法，例如gzip。                               |
     | Cache-Control    | 指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒。 |
     | Set-Cookie       | 告诉浏览器为当前页面所在的域设置cookie。                     |

   - 响应体：存放响应数据，前有空行

4. 响应数据设置

   - Web服务器对HTTP协议的响应数据进行了封装（HttpServletResponse），并在调用Controller方法时传递给了该方法
   - 通常无需手动设置响应状态码和响应头
   - @RestController中有@RequestBody注解
     - 作用：将controller返回值直接作为响应体的数据直接响应，如果返回值是对象/集合 -> 先转为json -> 再响应
     -  @RestController = @Controller + @RequestBody

   ```java
   /**
   * 方式一：基于HttpServletResponse 设置响应数据
   */
   @RequestMapping("/response")
   public void response(HttpServletResponse response) throws IOException {
     // 1.设置响应状态码
     response.setStatus(HttpServletResponse.SC_OK); // 通常不设置
     // 2，设置响应头
     response.setHeader("name", "wjk");
     // 3.设置响应体
     response.getWriter().write("<h1>hello world</h1>");
   }
   
   /**
   * 方式二：使用ResponseEntity -- Spring中提供的
   */
   @RequestMapping("/response2")
   public ResponseEntity<String> response2() {
     return ResponseEntity
             .status(401)
             .header("name", "javaweb")
             .body("<h1>hello world</h1>");
   }
   
   // @RestController
   // @RestController中有 @RequestBody 注解- 作用：将controller返回值直接作为响应体的数据直接响应，如果返回值是对象/集合 -> 先转为json -> 再响应
   // @RestController = @Controller + @RequestBody
   ```

## 分层解耦

遵循单一职责原则，便于复用、后期维护

### 三层架构

#### Controller

- 控制层
- 接收前端发送的请求，对请求进行处理，并响应数据

```java
@RestController 
public class UserController {

    /*@RequestMapping("/list")
    public List<User> list() throws Exception {
        // 1.加载并读取User.txt文件，获取用户数据
        InputStream in = this.getClass().getClassLoader().getResourceAsStream("user.txt");
        ArrayList<String> lines = IoUtil.readLines(in, StandardCharsets.UTF_8, new ArrayList<>());

        // 2.解析用户信息，封装为User对象 -> List集合
        List<User> userList = lines.stream().map(line -> {
            String[] parts = line.split(",");
            Integer id = Integer.parseInt(parts[0]);
            String username = parts[1];
            String password = parts[2];
            String name = parts[3];
            Integer age = Integer.parseInt(parts[4]);
            LocalDateTime updateTime = LocalDateTime.parse(parts[5], DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            return new User(id, username, password, name, age, updateTime);
        }).toList();

        // 3.返回数据 - JSON
        return userList;
    }*/

    private UserService userService = new UserServiceImpl();

    @RequestMapping("/list")
    public List<User> list() throws Exception {
        // 1.调用service，获取数据
        List<User> userList = userService.findAll();

        // 2.返回数据 - JSON
        return userList;
    }
}
```

##### 接收简单参数

- 接收简单参数：`Delete /depts?id=1`

- 方式一：通过原始的HttpServletRequest对象获取请求参数 `request.getParameter("id")`获取到字符串，再转换类型（用的不多）

   ```java
   // 方式一：HttpServletRequest 获取请求参数
   @DeleteMapping("/depts")
   public Result delete(HttpServletRequest request){
       String idStr = request.getParameter("id");
       int id = Integer.parseInt(idStr);
       System.out.println("根据ID删除部门：" + id);
       return Result.success();
   }
   ```

- 方式二：通过Spring提供的@RequestParam注解，将请求参数绑定给方法形参

   ```java
   // 方式二：@RequestParam
   // 注意：一旦声明了该注解，该参数在请求时必须传递，否则会报错（默认required为true）
   @DeleteMapping("/depts")
   public Result delete(@RequestParam(value = "id", required = false) Integer deptId){
       System.out.println("根据ID删除部门：" + deptId);
       return Result.success();
   }
   ```

- 方式三：如果请求参数名与形参变量名相同，直接定义方法形参即可接收（@RequestParam可以省略）-推荐

   ```java
   // 方式三：省略@RequestParam（前端传递的请求参数名与服务端方法形参名一致）
   @DeleteMapping("/depts")
   public Result delete(Integer id){
       System.out.println("根据ID删除部门：" + id);
       return Result.success();
   }
   ```

##### 接收请求体参数

- 接收Json格式的请求参数，通常使用一个实体对象进行接收

- 规则：JSON数据的键名与方法形参对象的属性名相同，并需要使用@RequestBody注解标识

  ```java
  @PostMapping("/depts")
  public Result add(@RequestBody Dept dept){
      System.out.println("新增部门：" + dept);
      return Result.success();
  }
  ```

##### 接收路径参数

- 接收路径参数：`Get /depts/1`

- 路径参数：通过请求URL直接传递参数，使用`{...}`来标识该路径参数，需要使用`@PathVariable`获取

- url中可以有多个路径参数

  ```java
  @GetMapping("/depts/{id}")
  public Result getInfo(@PathVariable("id") Integer deptId){
      System.out.println("根据ID查询部门：" + deptId);
      return Result.success();
  }
  ```

- 如果方法的形参名与路径参数名一致，可省略value属性值

  ```java
  @GetMapping("/depts/{id}")
  public Result getInfo(@PathVariable Integer id){
      System.out.println("根据ID查询部门：" + id);
      return Result.success();
  }
  ```

##### 接收数组参数

- 接收请求参数：`Delete /emps?ids=1,2,3`

- 方法一：在Controller中通过数组接收，参数名需与前端传递的名字一致

  ```java
  @DeleteMapping
  public Result delete(Integer[] ids){
      log.info("删除员工：{}", Arrays.toString(ids));
      return Result.success();
  }
  ```

- 方法二：在Controller中通过集合接收，参数名一致，并且必须加@RequestParam注解，推荐使用该方法

  ```java
  @DeleteMapping
  public Result delete(@RequestParam List<Integer> ids){
      log.info("删除员工：{}", ids);
      return Result.success();
  }
  ```

#### Service

- 业务逻辑层
- 处理具体的业务逻辑

```java
public class UserServiceImpl implements UserService {

    private UserDao userDao = new UserDaoImpl();

    @Override
    public List<User> findAll() {
        // 调用Dao获取数据
        List<String> lines = userDao.findAll();

        // 2.解析用户信息，封装为User对象 -> List集合
        List<User> userList = lines.stream().map(line -> {
            String[] parts = line.split(",");
            Integer id = Integer.parseInt(parts[0]);
            String username = parts[1];
            String password = parts[2];
            String name = parts[3];
            Integer age = Integer.parseInt(parts[4]);
            LocalDateTime updateTime = LocalDateTime.parse(parts[5], DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            return new User(id, username, password, name, age, updateTime);
        }).toList();

        return userList;
    }
}
```

#### Dao

- 数据访问层（Data Access Object）（持久层）
- 负责数据访问操作，包括数据的增、删、改、查

```java
public class UserDaoImpl implements UserDao {

    @Override
    public List<String> findAll() {
        // 1.加载并读取User.txt文件，获取用户数据
        InputStream in = this.getClass().getClassLoader().getResourceAsStream("user.txt");
        ArrayList<String> lines = IoUtil.readLines(in, StandardCharsets.UTF_8, new ArrayList<>());
        return lines;
    }
}
```

### 分层解耦

- 耦合与内聚
  - 耦合：衡量软件中各个层/各个模块的依赖关联程度
  - 内聚：软件中各个功能模块内部的功能联系
  - 软件设计原则：高内聚低耦合
- 分层解耦的思路：（Spring两大特性）
  - 控制反转：Inversion Of Control   IOC
    - 对象的创建控制权由程序自身转移到外部（容器），这种思想成为控制反转
  - 依赖注入：Dependency Injection  DI
    - 容器为应用程序提供运行时所依赖的资源，称为依赖注入
  - Bean对象
    - IOC容器中创建、管理的对象，称为Bean
- 实现
  - 将Dao及Service层的实现类，交给IOC容器管理
    - 在Dao和Service的实现类前加注解`@Component`
  - 为Controller及Service注入运行时所依赖的对象
    - 在类的定义前加注解`@Autowired`，并且不需要new对象

#### IOC

- 注解
  - 要把某个对象交给IOC容器管理，需要在对应的类加注解
  - 声明bean的时候，可以通过注解的value属性执行bean的名字，如果没有指定，默认为类名首字母小写

| 注解          | 说明                   | 位置                                              |
| ------------- | ---------------------- | ------------------------------------------------- |
| `@Component`  | 声明bean的基础注解     | 不属于以下三类时，用此注解（如常见工具类等）      |
| `@Controller` | `@Component`的衍生注解 | 标注在控制层类上                                  |
| `@Service`    | `@Component`的衍生注解 | 标注在业务层类上                                  |
| `@Repository` | `@Component`的衍生注解 | 标注在数据访问层类上（由于与mybatis整合，用的少） |

- 组件扫描
  - 前面声明bean的四大注解，要想生效，还需要被组件扫描注解`@ComponentScan`扫描
  - 该注解虽然没有显式配置，但是实际上已经包含在类启动累声明注解`@SpringBootApplication`中，默认扫描的范围是启动类所在包及其子包

#### DI

- 基于@Autowired进行依赖注入的常见三种方式：

  - 属性注入
    - 优点：代码简洁，方便快速开发
    - 缺点：隐藏了类之间的依赖关系，可能会破坏类的封装性
  - 构造器函数注入
    - 优点：能清晰地看到类的依赖关系，提高了代码的安全性
    - 缺点：代码繁琐，如果构造参数过多，可能会导致构造函数臃肿
    - 注意：如果只存在一个构造函数，可以省略注解@Autowired
  - setter注入
    - 优点：保持了类的封装性，依赖关系更清晰
    - 缺点：需要额外编写setter方法，增加了代码量

  ```java
  // 1.属性注入
  @RestController
  public class UserController {
  
      @Autowired
      private UserService userService;
  		// ...
  }
  
  // 2.构造器函数注入
  @RestController
  public class UserController {
  
      private final UserService userService;
      @Autowired
      public UserController(UserService userService) {
          this.userService = userService;
      }
  		// ...
  }
  
  // 3.setter注入
  @RestController
  public class UserController {
  
     	private UserService userService;
      @Autowired
      public void setUserService(UserService userService) {
          this.userService = userService;
      }
  		// ...
  }
  ```

- 注意事项

  - @Autowired注解，默认按照类型进行注入
  - 如果存在多个相同类型的bean，会报错，解决方案：
    - 方案一：在需要注解的类前增加 `@Primary`
    - 方案二：在使用的位置，使用`@Autowired`配合`@Qualifier("bean的名字")`
    - 方案三：在使用的位置，使用`@Resource(name="bean的名字")`

# MySQL

## 介绍

- MySQL连接
  - `mysql -u 用户名 -p 密码 [-h 数据库服务器IP地址  -P 端口号]`
- MySQL数据模型
  - 关系型数据库：建立在关系模型基础上，由多张相互连接的二维表组成的数据库
  - 特点：
    - 使用表存储数据，格式统一，便于维护
    - 使用SQL语言操作，标准统一，使用方便，可用于复杂查询

## SQL语句

- SQL：一门操作关系型数据库的编程语言，定义操作所有关系性数据库的统一标准

- 分类

  | 分类 | 全称                       | 说明                                                   |
  | ---- | -------------------------- | ------------------------------------------------------ |
  | DDL  | Data Definition Language   | 数据定义语言，用来定义数据库对象(数据库，表，字段)     |
  | DML  | Data Manipulation Language | 数据操作语言，用来对数据库表中的数据进行增删改         |
  | DQL  | Data Query Language        | 数据查询语言，用来查询数据库中表的记录                 |
  | DCL  | Data Control Language      | 数据控制语言，用来创建数据库用户、控制数据库的访问权限 |

### DDL

- 操作数据库

  ```sql
  -- 查询所有数据库
  show databases;
  
  -- 查询当前数据库
  select database();
  
  -- 使用/切换数据库
  use 数据库名;
  
  -- 创建数据库
  create database [if not exists] 数据库名 [default charset utf8mb4];
  
  -- 删除数据库
  drop database [if exists] 数据库名;
  
  -- database 可以替换为 schema
  -- MySQL8版本中，默认字符集为 utf8mb4
  ```

- 表结构-创建

  - 约束：约束是作用于表中字段上的规则，用于限制存储在表中的数据
  - 目的：保证数据库中数据的正确性、有效性和完整性

  | 约束     | 描述                                             | 关键字      |
  | -------- | ------------------------------------------------ | ----------- |
  | 非空约束 | 限制该字段值不能为null                           | not null    |
  | 唯一约束 | 保证字段的所有数据都是唯一、不重复的             | unique      |
  | 主键约束 | 主键是一行数据的唯一标识，要求非空且唯一         | primary key |
  | 默认约束 | 保存数据时，如果未指定该字段值，则采用默认值     | default     |
  | 外键约束 | 让两张表的数据建立连接，保证数据的一致性和完整性 | foreign key |

  ```sql
  create table tablename(
      字段1 字段类型 [约束] [comment 字段1注释],
      ......
      字段2 字段类型 [约束] [comment 字段2注释]
  )[comment 表注释];
  
  -- eg:
  create table user(
  	id int primary key comment auto_increment 'ID，唯一标识', -- 主键约束，自增
    username varchar(50) not null unique comment '用户名',  -- 非空且唯一
    name varchar(10) not null comment '姓名', -- 非空
    age int comment '年龄',
    gender char(1) default '男' comment '性别'  -- 默认
  )comment '用户信息表';
  ```

- 数据类型

  - 主要分为三类：数值类型、字符串类型、日期时间类型

  - 数值类型

    - 选取原则：满足业务需求的前提下，尽可能选择占用磁盘空间小的数据类型

    | 类型      | 大小(byte) | 有符号(SIGNED)范围                                    | 无符号(UNSIGNED)范围                                      | 描述             | 备注                                              |
    | --------- | ---------- | ----------------------------------------------------- | --------------------------------------------------------- | ---------------- | ------------------------------------------------- |
    | tinyint   | 1          | (-128, 127)                                           | (0, 255)                                                  | 小整数值         |                                                   |
    | smallint  | 2          | (-32768, 32767)                                       | (0, 65535)                                                | 大整数值         |                                                   |
    | mediumint | 3          | (-8388608, 8388607)                                   | (0, 16777215)                                             | 大整数值         |                                                   |
    | int       | 4          | (-2147483648, 2147483647)                             | (0, 4294967295)                                           | 大整数值         |                                                   |
    | bigint    | 8          | (-2^63, 2^63-1)                                       | (0, 2^64-1)                                               | 极大整数值       |                                                   |
    | float     | 4          | (-3.402823466 E+38, 3.402823466351 E+38)              | 0 和 (1.175494351 E+38, 3.402823466 E+38)                 | 单精度浮点数值   | float(5,2)：5表示整个数字长度，2 表示小数位个数   |
    | double    | 8          | (-1.7976931348623157 E+308, 1.7976931348623157 E+308) | 0 和 (2.2250738585072014 E-308, 1.7976931348623157 E+308) | 双精度浮点数值   | double(5,2)：5表示整个数字长度，2 表示小数位个数  |
    | decimal   | -          | -                                                     | -                                                         | 小数值(精度更高) | decimal(5,2)：5表示整个数字长度，2 表示小数位个数 |

  - 字符串类型

    - char：优势性能略高，劣势浪费磁盘空间
    - varchar：优势节约磁盘空间，劣势性能略低

    | 类型        | 大小                  | 描述                         |
    | ----------- | --------------------- | ---------------------------- |
    | **char**    | 0-255 bytes           | 定长字符串                   |
    | **varchar** | 0-65535 bytes         | 变长字符串                   |
    | tinyblob    | 0-255 bytes           | 不超过255个字符的二进制数据  |
    | tinytext    | 0-255 bytes           | 短文本字符串                 |
    | blob        | 0-65 535 bytes        | 二进制形式的长文本数据       |
    | text        | 0-65 535 bytes        | 长文本数据                   |
    | mediumblob  | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据 |
    | mediumtext  | 0-16 777 215 bytes    | 中等长度文本数据             |
    | longblob    | 0-4 294 967 295 bytes | 二进制形式的极大文本数据     |
    | longtext    | 0-4 294 967 295 bytes | 极大文本数据                 |

  - 日期时间类型

    | 类型      | 大小(byte) | 范围                                       | 格式                | 描述                     |
    | --------- | ---------- | ------------------------------------------ | ------------------- | ------------------------ |
    | date      | 3          | 1000-01-01 至 9999-12-31                   | YYYY-MM-DD          | 日期值                   |
    | time      | 3          | -838:59:59 至 838:59:59                    | HH:MM:SS            | 时间值或持续时间         |
    | year      | 1          | 1901 至 2155                               | YYYY                | 年份值                   |
    | datetime  | 8          | 1000-01-01 00:00:00 至 9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
    | timestamp | 4          | 1970-01-01 00:00:01 至 2038-01-19 03:14:07 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值，时间戳 |

- 表结构-查询、修改、删除

  ```sql
  show tables; -- 查询当前数据库的所有表
  
  desc 表名; -- 查询表结构
  
  show create table 表名; -- 查询建表语句
  
  alter table 表名 add 字段名 类型(长度) [comment 注释] [约束]; -- 添加字段
  
  alter table 表名 modify 字段名 新数据类型(长度); -- 修改字段类型
  
  alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束]; -- 修改字段名与字段类型
  
  alter table 表名 drop column 字段名; -- 删除字段
  
  alter table 表名 rename to 新表名; -- 修改表名
  
  drop table [if exists] 表名; -- 删除表
  ```

### DML

- Data Manipulation Language数据操作语言，对数据库中表的数据记录进行增删改操作

- 添加数据  INSERT

  ```sql
  -- 指定字段添加数据
  insert into 表名(字段名1, 字段名2) values (值1, 值2);
  
  -- 全部字段添加数据
  insert into 表名 values (值1, 值2, ...);
  
  -- 批量添加数据（指定字段）
  insert into 表名 (字段名1, 字段名2) values (值1, 值2), (值1, 值2);
  
  -- 批量添加数据（全部字段）
  insert into 表名 values (值1, 值2, ...), (值1, 值2, ...);
  ```

- 修改数据  UPDATE

  ```sql
  -- 修改数据
  update 表名 set 字段名1 = 值1, 字段名2 = 值2, ... [where 条件];
  ```

- 删除数据  DELETE

  ```sql
  -- 删除数据
  delete from 表名 [where 条件];
  ```

### DQL

- Data Query Language 数据查询语言，用来查询数据库表中的记录

- 关键字：SELTECT

  ```sql
  select
  	字段列表
  from
  	表名列表
  where
  	条件列表
  group by
  	分组字段列表
  having
  	分组后条件列表
  order by
  	排序条件列表
  limit
  	分页参数
  ```

- 基本查询  select...from...

  - 注意：*在实际开发中尽量少用--不直观，影响效率

  ```sql
  -- 查询多个字段
  select 字段1,字段2,字段3 from 表名;
  
  -- 查询所有字段(通配符)
  select * from 表名;
  
  -- 为查询字段设置别名，as关键字可以省略
  -- 别名中间有空格必须加引号，其余情况可以不加引号
  select 字段1 [as 别名1], 字段2 [as 别名2] from 表名;
  
  -- 去除重复记录
  select distinct 字段列表 from 表名;
  ```

- 条件查询 where

  ```sql
  -- 条件查询
  select	字段列表	from	表名列表	where	条件列表
  ```

  | 比较运算符          | 功能                                         |
  | ------------------- | -------------------------------------------- |
  | >                   | 大于                                         |
  | >=                  | 大于等于                                     |
  | <                   | 小于                                         |
  | <=                  | 小于等于                                     |
  | =                   | 等于                                         |
  | <> 或 !=            | 不等于                                       |
  | between ... and ... | 在某个范围之内(含最小、最大值)               |
  | in(....)            | 在in之后的列表中的值，多选一                 |
  | like 占位符         | 模糊匹配(`_`匹配单个字符，`%`匹配任意个字符) |
  | is null             | 是null                                       |

  | 逻辑运算符 | 功能                         |
  | ---------- | ---------------------------- |
  | and 或 &&  | 并且（多个条件同时成立）     |
  | or 或 \|\| | 或者（多个条件任意一个成立） |
  | not 或 !   | 非，不是                     |

- 分组查询 group by

  - 聚合函数：将一列数据作为一个整体，进行纵向计算（不统计null值）
    - count：统计数量
    - max：求最大值
    - min：求最小值
    - avg：求平均值
    - sum：求和

  ```sql
  -- 聚合函数
  -- 注意：所有的聚合函数不参与null的统计
  
  -- 1. 统计该企业员工数量 - count
  -- count(字段)
  select count(id) from emp;
  
  -- count(*) : 推荐，性能最高
  select count(*) from emp;
  
  -- count(常量) ： 其次推荐
  select count(1) from emp;
  
  -- 2. 统计该企业员工的平均薪资 - avg
  select avg(salary) from emp;
  
  -- 3. 统计该企业员工的最低薪资 - min
  select min(salary) from emp;
  
  -- 4. 统计该企业员工的最高薪资 - max
  select max(salary) from emp;
  
  -- 5. 统计该企业每月要给员工发放的薪资总额(薪资之和) - sum
  select sum(salary) from emp;
  ```

- 分组查询

  - where和having的区别
    - 执行时机不同：where是分组之前进行过滤，不满足where条件的不参与分组；而having是对分组之后对结果进行过滤
    - 判断条件不同：where不能对聚合函数进行判断，而having可以
  - 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义
  - 执行顺序： where > 聚合函数 > having

  ```sql
  -- 分组查询
  select	字段列表	from	表名列表	[where	条件列表] group by 分组字段名 [having 分组后过滤条件];
  
  -- 分组之后，select后的字段列表不能随意书写，能写的一般是分组字段 + 聚合函数
  -- 1. 根据性别分组 , 统计男性和女性员工的数量
  select gender, count(*) from emp group by gender;
  
  -- 2. 先查询入职时间在 '2015-01-01' (包含) 以前的员工 , 并对结果根据职位分组 , 获取员工数量大于等于2的职位
  select job, count(*) from emp
  where entry_date <= '2015-01-01'
  group by job
  having count(*) >= 2;
  ```

- 排序查询 order by

  - 排序方式：升序asc，降序desc；默认为升序，可不写
  - 如果多字段排序，当第一个字段相同时，才会根据第二个字段进行排序（多字段排序，在字段后用逗号连接）

  ```sql
  -- 排序查询
  select	字段列表	from	表名列表	[where	条件列表] [group by 分组字段名 having 分组后过滤条件] order by 排序字段 排序方式 [,排序字段2 排序方式];
  ```

- 分页查询 limit

  - 起始索引从0开始
  - 分页查询是数据库的方言，不同数据库有不同的实现，MySQL是LIMIT
  - 如果起始索引为0，起始索引可以省略，直接写为 `limit 查询记录数`

  ```sql
  -- 分页查询
  select	字段列表	from	表名列表	[where	条件列表] [group by 分组字段名 having 分组后过滤条件] [order by 排序字段 排序方式] limit 起始索引,查询记录数;
  -- 起始索引 = (页码 - 1) * 每页展示记录数
  ```

- count函数

  ```sql
  -- case函数：case 表达式 when val1 then result1 ... else ... end
  select
      (case job when 1 then '班主任'
          when 2 then '讲师'
          when 3 then '学生主管'
          when 4 then '教研主管'
          when 5 then '咨询师'
          else '其他' end) pos,
      count(*) num
  from emp group by job
  order by num ;
  
  -- case函数：case when 条件表达式1 then result1 ... else ... end
  select
      (case
          when job=1 then '班主任'
          when job=2 then '讲师'
          when job=3 then '学生主管'
          when job=4 then '教研主管'
          when job=5 then '咨询师'
          else '其他' end) pos,
      count(*) num
  from emp group by job
  order by num ;
  ```

- if函数

  ```sql
  -- 统计员工性别人数
  -- if函数： if(条件, true_value, false_value)
  select
      if(gender=1, '男性员工', '女性员工') name,
      count(*) value
  from emp group by gender;
  ```

## 多表关系

### 一对多（多对一）

- 场景：部门与员工的关系（一个部门有多个员工）

- 在数据库表中多多一方，添加字段，来关联一的一方的主键

- 外键约束

  - 可以通过外键约束保证多表操作中数据的一致性和完整性
  - 物理外键
    - 概念：使用foreign key 定义外键关联另外一张表
    - 缺点：
      - 影响增删改的效率（需要检查外键关系）
      - 仅用于单结点数据库，不适用于分布式、集群场景
      - 容易引发数据库的死锁问题，消耗性能

  ```sql
  -- 创建表时指定
  create table 表名(
      字段名 数据类型,
      ...
      [constraint] [外键名称] foreign key (外键字段名) references 主表(字段名)
  );
  
  -- 创建表后，添加外键
  alter table 表名 add constraint 外键名称 foreign key (外键字段名) references 主表(字段名);
  alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id);
  ```

  - 逻辑外键
    - 概念：在业务层逻辑中，解决外键关联
    - 通过逻辑外键，就能很方便的解决上述问题

### 一对一

- 场景：用户与身份证信息的关系
- 关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以提升效率
- 实现：在任意一方增加外键，关联另一方的主键，并且设置外键为唯一的（UNIQUE）

### 多对多

- 场景：学生与课程的关系
- 关系：一个学生可选修多门课程，一门课程可以供多个学生选择
- 实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键

### 多表查询

- 笛卡尔积：指在数学中，两个集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）

- 连接查询

  - 内连接：查询A、B交集部分的数据

  ```sql
  -- 1.隐式内连接(常见)
  select 字段列表 from 表1, 表2 where 连接条件 ...;
  select emp.id, emp.name, dept.name from emp, dept where emp.dept_id = dept.id;
  
  -- 2.显式内连接
  select 字段列表 from 表1 [inner] join 表2 on 连接条件 ...;
  select emp.id, emp.name, dept.name from emp inner join dept on emp.dept_id = dept.id;
  select emp.id, emp.name, dept.name from emp join dept on emp.dept_id = dept.id;
  
  -- 为表起别名，来简化书写
  select 字段列表 from 表1 [as] 别名1, 表2 [as] 别名2 where 连接条件 ...;
  select e.id, e.name, d.name from emp e join dept d on e.dept_id = d.id where e.gender = 1 and e.salary > 8000;
  ```

  - 外连接
    - 左外连接：查询左表所有数据（包括两张表中交集部分数据）
    - 右外连接：查询右表所有数据（包括两张表中交集部分数据）

  ```sql
  -- 左外连接
  select 字段列表 from 表1 left [outer] join 表2 on 连接条件 ...;
  select e.name, d.name from emp e left join dept d on e.dept_id = d.id;
  
  -- 右外连接
  select 字段列表 from 表1 right [outer] join 表2 on 连接条件 ...;
  select d.name, e.name from emp e right join dept d on e.dept_id = d.id;
  ```

- 子查询（嵌套查询）

  - SQL语句中嵌套select语句
  - 形式：`select * from t1 where column1 = (select column1 from t2 ...)`
  - 说明：子查询外部的语句可以是insert/update/delete/select的任意一个，最常见的是select
  - 分类
    - 标量子查询：子查询返回的结果为单个值
    - 列子查询：子查询返回的结果为一列
    - 行子查询：子查询返回的结果为一行
    - 表子查询：子查询返回的结果为多列多行
  - 先对需求做拆分，明确具体的步骤，然后再逐步编写SQL语句

  ```sql
  -- 标量子查询
  -- A. 查询 最早入职 的员工信息
  select * from emp where entry_date = (select min(entry_date) from emp);
  
  -- 列子查询
  -- A. 查询 "教研部" 和 "咨询部" 的所有员工信息
  select * from emp where dept_id in (select id from dept where name = '教研部' or name = '咨询部');
  
  -- 行子查询
  -- A. 查询与 "李忠" 的薪资 及 职位都相同的员工信息 ;
  select * from emp where salary = (select salary from emp where name = '李忠') and job = (select job from emp where name = '李忠');
  -- 优化
  select * from emp where (salary, job) = (select salary, job from emp where name = '李忠');
  
  -- 表子查询
  -- A. 获取每个部门中薪资最高的员工信息
  select * from emp e, (select dept_id, max(salary) max_sal from emp group by dept_id) a
  where e.dept_id = a.dept_id and e.salary = a.max_sal;
  ```

## 事务

- 事务是一组操作的集合，是一个不可分割的工作单位。事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些成功要么同时成功，要么同时失败

- 操作：

  - 开启事务：`start transaction` /`begin`
  - 提交事务：`commit`
  - 回滚事务：`rollback`

- Spring的事务管理

  - 注解：@Transactional
  - 作用：将当前方法交给spring进行事务管理，方法执行前开启事务；成功执行完毕后提交事务；出现异常                回滚事务
  - 位置：业务层service的方法上、类上、接口上，推荐加在操作了多次数据库的方法上
  - 设置日志级别：

  ```yaml
  logging:
    level:
      org.springframework.jdbc.support.JdbcTransactionManager: debug
  ```

  - rollbackFor
    - 该属性用于控制出现何种异常类型，回滚事务
    - 默认出现运行时异常RuntimeException才会回滚
    - 如果想要所有异常都回滚： `@Transaction(rollbackFor = {Exception.class})`

  - propagation
    - 事务传播行为：指当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制

    | 属性值        | 含义                                                         |
    | ------------- | ------------------------------------------------------------ |
    | REQUIRED      | 【默认值】需要事务，有则加入，无则创建新事务                 |
    | REQUIRES_NEW  | 需要新事务，无论有无，总是创建新事务                         |
    | SUPPORTS      | 支持事务，有则加入，无则在无事务状态中运行                   |
    | NOT_SUPPORTED | 不支持事务，在无事务状态下运行，如果当前存在已有事务，则挂起当前事务 |
    | MANDATORY     | 必须有事务，否则抛异常                                       |
    | NEVER         | 必须没事务，否则抛异常                                       |

    - 绝大部分都默认即可，但是希望两个方法在独立的事务中运行不互相影响的话可设置为REQUIRES_NEW

- 四大特性 ACID

  - 原子性Atomicity：事务是不可分割的最小单元，要么全部成功，要么全部失败
  - 一致性Consistency：事务完成时，必须使所有的数据都保持一致状态
  - 隔离性Isolation：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行
  - 持久性Durability：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的


# Java程序操作数据库

## JDBC

Java DataBase Connectivity 使用Java语言操作关系型数据库的一套API

### 代码实现

- 准备：创建maven项目，引入依赖

  ```xml
  <dependency>
      <groupId>com.mysql</groupId>
      <artifactId>mysql-connector-j</artifactId>
      <version>8.0.33</version>
  </dependency>
  ```

- 代码实现：编写JDBC程序，操作数据库

  ```java
  // 1.注册驱动
  Class.forName("com.mysql.cj.jdbc.Driver");
  
  // 2.获取数据库连接
  String url = "jdbc:mysql://localhost:3306/learning";
  String username = "root";
  String password = "wjk";
  Connection connection = DriverManager.getConnection(url, username, password);
  
  // 3.获取SQL语句执行对象
  Statement statement = connection.createStatement();
  
  // 4.执行SQL
  int i = statement.executeUpdate("update user set age = 25 where id = 1"); // DML
  System.out.println("SQL执行完毕影响的记录数为：" + i);
  
  // 5.释放资源
  statement.close();
  connection.close();
  ```

### 使用JDBC查询数据

- ResultSet 结果集对象

  - `ResultSet rs = statement.executeQuery()`
  - `next()`：将光标从当前位置向前移动一行，并判断当前行是否为有效行，返回值为boolean
    - true：有效行，当前行有数据
    - false：无效行，当前行无数据
  - `getXxx(...)`：获取数据，可以根据列的编号获取，也可以根据列名获取（推荐）

  ```java
  String url = "jdbc:mysql://localhost:3306/learning";
  String username = "root";
  String password = "wjk";
  
  Connection conn = null;
  PreparedStatement stmt = null;
  ResultSet rs = null;  // 封装查询返回的结果
  try {
      // 1.注册驱动
      Class.forName("com.mysql.cj.jdbc.Driver");
  
      // 2.获取数据库连接
      conn = DriverManager.getConnection(url, username, password);
  
      // 3.执行查询
      // 预编译SQL 效率高且更安全
      String sql = "select id, username, password, name, age from user where username = ? and password = ?";
      stmt = conn.prepareStatement(sql);
      stmt.setString(1, "daqiao");
      stmt.setString(2, "123456");
  
      rs = stmt.executeQuery();
  
      // 4.处理结果集
      while (rs.next()){
          User user = new User(
                  rs.getInt("id"),
                  rs.getString("username"),
                  rs.getString("password"),
                  rs.getString("name"),
                  rs.getInt("age")
          );
          System.out.println(user);
      }
  } catch (Exception e){
      e.printStackTrace();
  } finally {
      // 5.关闭资源
      try {
          if (rs != null)
              rs.close();
          if (stmt != null)
              stmt.close();
          if (conn != null)
              conn.close();
      }catch (SQLException se){
          se.printStackTrace();
      }
  }
  ```

### 预编译SQL

- 优势一：可以防止SQL注入，更安全
  - SQL注入：通过控制输入来修改事先定义好的SQL语句，以达到执行代码对服务器进行攻击的方法
- 优势二：性能更高
  - java发送后，数据库的操作：查询缓存中是否有这条语句 -> (没缓存的话)SQL语法解析检查 -> 优化SQL -> 编译SQL (缓存起来) -> 执行SQL
  - 预编译的SQL语句都一样

## MyBatis

MyBatis是一款优秀的持久层框架，用于简化JDBC的开发

### 入门程序

- 准备工作
  - 创建Springboot工程，引入Mybatis依赖
  - 准备数据库表、实体类
  - application.properties中配置数据库连接信息
- 定义Mapper接口（@Mapper），编写SQL
- 辅助配置
  - SQL提示
    - 默认SQL语句是不识别的
    - 做配置：Show Context Actions -> Inject language or reference -> MySQL
    - 再配置IDEA中的database（和DataGrip一样的配置，但是要选择具体的数据库）
  - 配置Mybatis的日志输出
    - 再配置中加入：`mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl`

### 数据库连接池

- 数据库连接池是一个容器，负责分配、管理数据库连接Connection

- 允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个

- 释放  空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏

- 优势

  - 资源重用
  - 提升系统响应速度
  - 避免数据库连接遗漏

- 标准接口：DataSource

  - 功能：获取连接 `Connection getConnection() thorws SQLException;`

  - 常见产品：Druid（阿里巴巴开源的数据库连接池项目），Hikari（SpringBoot默认）

  - 切换数据库连接池 Druid：

    ```xml
    <!-- pom.xml -->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid-spring-boot-starter</artifactId>
        <version>1.2.23</version>
    </dependency>
    ```

    ```properties
    # application.properties
    spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
    ```

### 增删改查操作

- **Mybatis中的 # 与 $**(面试题)

  | 符号    | 说明                                               | 场景                       | 优缺点             |
  | ------- | :------------------------------------------------- | -------------------------- | ------------------ |
  | #{...}  | 占位符。执行时，会将其替换为?，生成预编译SQL       | 参数值传递                 | 安全，性能高，推荐 |
  | ${....} | 拼接符。直接将参数拼接在SQL语句中，存在SQL注入问题 | 表名、字段名动态设置时使用 | 不安全，性能低     |

- 删除用户 delete

- 新增用户 insert

- 修改用户 update

- 查询用户 select

  - @Param：为接口的形参起名字
  - 基于官方骨架创建的springboot项目中，接口编译时会保留方法形参名，@Param注解可以省略

```java
@Mapper // 应用程序在运行时，会自动为该接口创建一个实现对象（代理对象），并且会自动将该实现类对象存入IOC容器中，成为bean对象
public interface UserMapper {

    // 查询所有用户
    @Select("select id, username, password, name, age from user")
    public List<User> findAll();

    // 根据id删除用户
    @Delete("delete from user where id = #{id}")
    // public void deleteById(Integer id);
    public Integer deleteById(Integer id);

    // 新增用户
    // 后面的参数是对象中的属性名
    @Insert("insert into user(username, password, name, age) value (#{username}, #{password}, #{name}, #{age})")
    public void insert(User user);

    // 更新用户
    @Update("update user set username = #{username}, password = #{password}, name = #{name}, age = #{age} where id = #{id}")
    public void update(User user);

    // 根据用户名和密码查询用户信息
    @Select("select id, username, password, name, age from user where username=#{username} and password=#{password}")
    // public User selectByUsernamAndPassword(@Param("username") String username, @Param("password") String password);
    public User selectByUsernamAndPassword(String username, String password);
}
```

### XML映射配置

- 在Mybatis中，既可以通过注解配置SQL语句，也可以通过XML配置文件配置SQL语句

- 默认规则

  - XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）
  - XML映射文件的namespace属性为Mapper接口 全限定名
  - XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE mapper
          PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
          "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  <mapper namespace="com.wjk.mapper.UserMapper">
      <!-- 查询所有用户 -->
      <!-- resultType: 查询返回的单条记录所封装的类型 -->
      <select id="findAll" resultType="com.wjk.pojo.User">
          select id, username, password, name, age from user
      </select>
  </mapper>
  ```

- 使用场景

  - 如果是简单的增删改查功能，则直接使用注解即可
  - 如果需要实现复杂的SQL功能，则建议使用XML来配置映射语句

- 辅助配置

  - 配置XML映射文件的位置：`mybatis.mapper-locations=classpath:mapper/*.xml`（application.properties中配置自定义的位置）（严格按照规范的话，可以不配置）
  - MybatisX：基于IDEA的快速开发mybatis的插件

### 数据封装

#### @Results

- 实体类属性名和数据库表查询返回的字段名一致时，mybatis会自动封装


- 如果不一致，不能自动封装


- 解决方法：

  - 手动结果映射：通过@Results及@Result，进行手动结果映射

    ```java
    // mapper中，方法前定义
    @Results({
            @Result(column = "create_time", property = "createTime"),
            @Result(column = "update_time", property = "updateTime")
    })
    @Select("select id, name, create_time, update_time from dept order by update_time desc")
    List<Dept> findAll();
    ```

  - 起别名：在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样

    ```java
    @Select("select id, name, create_time createTime, update_time updateTime from dept order by update_time desc")
    List<Dept> findAll();
    ```

  - 开启驼峰命名：如果字段名与属性名符合驼峰命名规则，mybatis会自动通过驼峰命名规则映射，推荐

    ```yaml
    # mybatis的配置信息
    mybatis:
      configuration:
        # 开启驼峰命名映射开关
        map-underscore-to-camel-case: true 
    ```

#### ResultMap

- 使用情形

  - 如果查询返回的字段名与实体的属性名可以直接对应，用resultType
  - 如果查询返回的字段名与实体的属性名对应不上，或实体属性比较复杂，使用resultMap手动封装

- 使用ResultMap - 自定义结果集

- id使用id标签

- 普通字段使用result标签，column-数据库字段名，property-实体类属性名

- 集合需要使用collection标签

  ```xml
  <!-- 定义ResultMap -->
  <resultMap id="empResultMap" type="com.wjk.pojo.Emp">
      <id column="id" property="id"/>
      <result column="username" property="username" />
      <result column="password" property="password" />
      <result column="name" property="name" />
      <result column="gender" property="gender" />
      <result column="phone" property="phone" />
      <result column="job" property="job" />
      <result column="salary" property="salary" />
      <result column="image" property="image" />
      <result column="entry_date" property="entryDate" />
      <result column="dept_id" property="deptId" />
      <result column="create_time" property="createTime" />
      <result column="update_time" property="updateTime" />
  
      <!--封装工作经历信息-->
      <collection property="exprList" ofType="com.wjk.pojo.EmpExpr">
          <id column="ee_id" property="id"/>
          <result column="ee_empid" property="empId"/>
          <result column="ee_begin" property="begin"/>
          <result column="ee_end" property="end"/>
          <result column="ee_company" property="company"/>
          <result column="ee_job" property="job"/>
      </collection>
  </resultMap>
  
  <!-- 根据id查询员工基本信息以及工作经历信息 -->
  <select id="getById" resultMap="empResultMap">
      select
          e.*,
          ee.id ee_id,
          ee.emp_id ee_empid,
          ee.begin ee_begin,
          ee.end ee_end,
          ee.company ee_company,
          ee.job ee_job
      from emp e left join emp_expr ee on e.id = ee.emp_id where e.id = #{id};
  </select>
  ```

# 开发模式

## 开发规范

- 前端混合开发
  - 前后端代码写在同一项目下
  - 缺点：分工不明确，不便管理，难以维护
- 前后端分离开发
  - 当前最为主流的开发模式
  - 分为前端项目（页面渲染，独立部署在nginx中）和后端项目（业务逻辑的处理，独立部署在tomcat）
  - 接口文档
  - 流程：需求分析 -> 接口设计（API接口文档）-> 前后端并行开发 -> 测试 -> 前后端联调测试

## Restful风格

- REST：Representational State Transfer 表述性状态转换，是一种软件结构风格
- URL定位资源，HTTP动词描述操作
- 简洁、规范
- 需要加s（复数）

| REST风格url                   | 请求方式 | 含义            |
| ----------------------------- | -------- | --------------- |
| http://localhost:8080/users/1 | GET      | 查询id为1的用户 |
| http://localhost:8080/users/1 | DELETE   | 删除id为1的用户 |
| http://localhost:8080/users   | POST     | 新增用户        |
| http://localhost:8080/users   | PUT      | 修改用户        |

## nginx

- nginx-反向代理：反向代理是一种网络架构技术，通过反向代理服务器为后端服务器做代理（安全、灵活、负载均衡）

- Nginx中反向代理的配置：

  ```
  location ^~ /api/ {
      rewrite ^/api/(.*)$ /$1 break;
      proxy_pass http://localhost:8080;
  }
  ```

- mac安装和部署nginx

  - 安装：命令`brew install nginx`

  - 命令：

    - 启动指令: `nginx` 或者是 `sudo nginx`
    - 重启 Nginx 指令: `sudo nginx -s reload`
    - 停止 Nginx 指令: `sudo nginx -s quit`, 或者直接: `killall nginx`
    - 执行查找配置文件所在目录指令: `nginx -t`
      - nginx: the configuration file /opt/homebrew/etc/nginx/nginx.conf syntax is ok
      - nginx: configuration file /opt/homebrew/etc/nginx/nginx.conf test is successful
      - 输入open即可打开

  - 部署：

    - 打开安装目录
      - 执行： `brew info nginx `
      - 打开：`/opt/homebrew/Cellar/nginx/1.29.3 `
    - 替换html文件夹

    <img src="./images/image-20251114170629660.png" alt="image-20251114170629660" style="zoom:40%;" />

    - 再次修改 nginx.conf 文件, 目的是找到你的 前端 文件, nginx.conf 的打开方式上面已经说了, 就是打开修改端口号的那个文件

    <img src="./images/image-20251114170828508.png" alt="image-20251114170828508" style="zoom:50%;" />

    - 部署完要记得重启一下 nginx, 重启指令 `sudo nginx -s reload`.

# 其他技术

## 日志

- 用来记录应用程序的运行信息、状态信息、错误信息等
- 作用：数据追踪、性能优化、问题排查、系统监控
- 日志技术
  - JUL：java.util.logging 官方日志框架。配置相对简单，但不够灵活，性能较差
  - Log4j：一个流行的日志框架，提供了灵活的配置选项，支持多种输出目标
  - Logback：基于Log4j升级，提供了更多的功能和配置选项，性能优于Log4j，推荐使用
  - Slf4j：简单日志门面，提供了一套日志操作的标准接口及抽象类，允许应用程序使用不同的底层日志框架
    - 抽象类，不提供实现，真正的实现仍是Log4j、Logback

### Logback

#### 使用

- 准备工作：引入logback依赖（springboot项目中该依赖已传递），配置logback.xml

  ```xml
  <!-- pom.xml -->
  <dependency>
      <groupId>ch.qos.logback</groupId>
      <artifactId>logback-classic</artifactId>
      <version>1.4.11</version>
  </dependency>
  ```

  ```xml
  <!-- logback.xml -->
  <?xml version="1.0" encoding="UTF-8"?>
  <configuration>
      <!-- 控制台输出 -->
      <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
          <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
              <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度  %logger{50}: 最长50个字符(超出.切割)  %msg：日志消息，%n是换行符 -->
              <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
          </encoder>
      </appender>
      
      <!-- 日志输出级别 -->
      <root level="debug">
          <appender-ref ref="STDOUT" />
      </root>
  </configuration>
  ```

- 记录日志：定义日志记录对象Logger，记录日志

  ```java
  // 可以用lombok提供的@Slf4j注解替代
  @Slf4j
  public class LogTest {
  
      // private static final Logger log = LoggerFactory.getLogger(LogTest.class);
  
      @Test
      public void testLog(){
          // System.out.println(LocalDateTime.now() + " : 开始计算...");
          log.debug("开始计算...");
  
          int sum = 0;
          int[] nums = {1, 5, 3, 2, 1, 4, 5, 4, 6, 7, 4, 34, 2, 23};
          for (int num : nums) {
              sum += num;
          }
  
          log.info("计算结果为: "+sum);
          // System.out.println("计算结果为: "+sum);
          // System.out.println(LocalDateTime.now() + "结束计算...");
          log.debug("结束计算...");
      }
  
  }
  ```

#### 配置文件

- 配置文件名：logback.xml

- 该配置文件是对Logback日志框架输出的日志进行控制的，可以配置输出的格式、位置及日志开关等

- 常用的两种输出日志的位置：控制台、系统文件

  ```xml
  <!-- 控制台输出 -->
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">...</appender>
  <!-- 系统文件输出 -->
  <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">...</appender>        
  ```

- 可以配置日志的开关  ALL/OFF

  ```xml
  <!-- 日志输出级别 -->
  <root level="ALL">
      <appender-ref ref="STDOUT" />
    	<appender-ref ref="FILE" />
  </root>
  ```

- 完整配置文件

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <configuration>
      <!-- 控制台输出 -->
      <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
          <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
              <!--格式化输出：%d 表示日期，%thread 表示线程名，%-5level表示级别从左显示5个字符宽度，%logger显示日志记录器的名称， %msg表示日志消息，%n表示换行符 -->
              <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
          </encoder>
      </appender>
  
      <!-- 系统文件输出 -->
      <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
          <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
              <!-- 日志文件输出的文件名, %i表示序号 -->
              <FileNamePattern>/Users/jingmo/Desktop/projects/ideaProjects/web-basic-learning-tilas/log/tlias-%d{yyyy-MM-dd}-%i.log</FileNamePattern>
              <!-- 最多保留的历史日志文件数量 -->
              <MaxHistory>30</MaxHistory>
              <!-- 最大文件大小，超过这个大小会触发滚动到新文件，默认为 10MB -->
              <maxFileSize>10MB</maxFileSize>
          </rollingPolicy>
  
          <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
              <!--格式化输出：%d 表示日期，%thread 表示线程名，%-5level表示级别从左显示5个字符宽度，%msg表示日志消息，%n表示换行符 -->
              <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n</pattern>
          </encoder>
      </appender>
  
      <!-- 日志输出级别 -->
      <root level="INFO">
          <appender-ref ref="STDOUT" />
          <appender-ref ref="FILE" />
      </root>
  </configuration>
  ```

### 日志级别

- 指的是日志信息的类型，日志都会分级别，常见日志级别（级别由低到高）：

| 日志级别 | 说明                                                         | 记录方式           |
| -------- | ------------------------------------------------------------ | ------------------ |
| trace    | 追踪，记录程序运行轨迹 【使用很少】                          | `log.trace("...")` |
| debug    | 调试，记录程序调试过程中的信息，实际应用中一般将其视为最低级别 【使用较多】 | `log.debug("...")` |
| info     | 记录一般信息，描述程序运行的关键事件，如：网络连接、io操作 【使用较多】 | `log.info("...")`  |
| warn     | 警告信息，记录潜在有害的情况 【使用较多】                    | `log.warn("...")`  |
| error    | 错误信息 【使用较多】                                        | `log.error("...")` |

## 分页查询

- 原始方式

  - 查询总记录数+分页查询

  ```java
  // Controller
  @GetMapping
  public Result page(@RequestParam(defaultValue = "1") Integer page,@RequestParam(defaultValue = "10") Integer pageSize){
      log.info("分页查询：{}, {}", page, pageSize);
      PageResult<Emp> pageResult = empService.page(page, pageSize);
      return Result.success(pageResult);
  }
  
  // ServiceImpl
  public PageResult<Emp> page(Integer page, Integer pageSize) {
      // 1.调用mapper接口查询总记录数
      Long total = empMapper.count();
  
      // 2.调用mapper接口查询结果列表
      Integer start = (page - 1) * pageSize;
      List<Emp> rows = empMapper.list(start, pageSize);
  
      // 3.封装结果
      return new  PageResult<Emp>(total, rows);
  }
  
  // Mapper
  @Select("select count(*) from emp e left join dept d on e.dept_id = d.id")
  public Long count();
  
  // 分页查询
  @Select("select e.*, d.name deptName from emp e left join dept d on e.dept_id = d.id " 					+"order by e.update_time desc limit #{start}, #{pageSize}")
  public List<Emp> list(Integer start, Integer pageSize);
  
  // PageResult
  public class PageResult<T> {
      private Long total;
      private List<T> rows;
  }
  ```

- PageHelper

  - 第三方提供的在Mybatis框架中用来实现分页的插件，用来简化分页操作，提高开发效率

  - 使用步骤：

    - 引入依赖 pagehelper-spring-boot-starter

    ```xml
     <!-- 分页查询 -->
    <dependency>
        <groupId>com.github.pagehelper</groupId>
        <artifactId>pagehelper-spring-boot-starter</artifactId>
        <version>1.4.7</version>
    </dependency>
    ```

    - 定义Mapper接口的查询方法

    ```java
    // 分页查询
    @Select("select e.*, d.name deptName from emp e left join dept d on e.dept_id = d.id order by e.update_time desc")
    public List<Emp> list();
    ```

    - 在Service方法中实现分页查询

    ```java
    // PageHelper 分页查询
    @Override
    public PageResult<Emp> page(Integer page, Integer pageSize) {
        // 1.设置分页参数
        PageHelper.startPage(page, pageSize);
    
        // 2.执行查询
        List<Emp> empList = empMapper.list();
    
        // 3.解析查询结果，并封装
        Page<Emp> p = (Page<Emp>) empList;
    
        return new PageResult<Emp>(p.getTotal(), p.getResult());
    }
    ```

  - 实现机制

    - 对SQL语句进行改进，一个为统计数量，一个进行分页查询

  - 注意事项

    - 定义的SQL语句结尾不能加分号
    - PageHelper仅仅能对紧跟在其后的第一个查询语句进行分页处理

## 条件查询

- 参数过多时，可以定一个新的对象来接收参数

  ```java
  // EmpQueryParam
  @Data
  public class EmpQueryParam {
      private Integer page = 1;  // 页码
      private Integer pageSize = 10;  // 每页展示记录数
      private String name; //姓名
      private Integer gender; //性别
      @DateTimeFormat(pattern = "yyyy-MM-dd")
      private LocalDate begin; //入职时间-开始
      @DateTimeFormat(pattern = "yyyy-MM-dd")
      private LocalDate end; //入职时间-结束
  }
  
  // controller
  @GetMapping
  public Result page(EmpQueryParam empQueryParam){
      log.info("分页查询：{}", empQueryParam);
      PageResult<Emp> pageResult = empService.page(empQueryParam);
      return Result.success(pageResult);
  }
  
  // service
  @Override
  public PageResult<Emp> page(EmpQueryParam empQueryParam) {
      PageHelper.startPage(empQueryParam.getPage(), empQueryParam.getPageSize());
      List<Emp> empList = empMapper.list(empQueryParam);
      Page<Emp> p = (Page<Emp>) empList;
      return new PageResult<Emp>(p.getTotal(), p.getResult());
  }
  
  // mapper
  <mapper namespace="com.wjk.mapper.EmpMapper">
      <select id="list" resultType="com.wjk.pojo.Emp">
          select e.*, d.name deptName from emp e left join dept d on e.dept_id = d.id
          where
              e.name like concat('%', #{name},'%')
              and e.gender = #{gender}
              and e.entry_date between #{begin} and #{end}
          order by update_time desc
      </select>
  </mapper>
  ```

- 动态SQL

  - 随着用户的输入或外部条件的变化而变化
  - <if>：判断条件是否成立，如果条件为true，则拼接SQL
  - <where>：根据查询条件，来生成where关键字，并自动去除条件前面多余的and或or

  ```xml
  <mapper namespace="com.wjk.mapper.EmpMapper">
      <select id="list" resultType="com.wjk.pojo.Emp">
          select e.*, d.name deptName from emp e left join dept d on e.dept_id = d.id
          <where>
              <if test="name != null and name != ''">
                  e.name like concat('%', #{name},'%')
              </if>
              <if test="gender != null">
                  and e.gender = #{gender}
              </if>
              <if test="begin != null and end != null">
                  and e.entry_date between #{begin} and #{end}
              </if>
          </where>
          order by update_time desc
      </select>
  </mapper>
  ```

  - <foreach>
    - collection--集合名称；item--集合遍历出来的元素/项；separator--每一次遍历使用的分割符
    - open--遍历开始前拼接的片段；close--遍历结束后拼接的片段

  ```xml
  <!--  批量保存员工工作经历信息  -->
  <insert id="insertBatch">
      insert into emp_expr (emp_id, begin, end, company, job) values
      <foreach collection="exprList" item="expr" separator=",">
          (#{expr.empId}, #{expr.begin}, #{expr.end}, #{expr.company}, #{expr.job})
      </foreach>
  </insert>
  ```


## 文件上传

### 文件上传

- 前端

  - 三要素：必须post，属性必须multipart/form-data，必须有一个文件的表单项（type为file）

  ```html
  <form action="/upload" method="post" enctype="multipart/form-data">
    ...
    <input type="file" name="file">
  </form>
  ```

- 服务器端

  - Controller层的参数有一个MultipartFile类型的参数来接收文件

  ```java
  @PostMapping("/upload")
  public Result upload(String name, Integer age, MultipartFile file){
      log.info("接收到的参数值：{},{},{}", name, age, file);
      return Result.success();
  }
  ```

- 配置文件上传大小

  ```yaml
  spring:
    servlet:
      multipart:
        # 最大单个文件大小
        max-file-size: 10MB
        # 最大请求大小（包括所有文件和表单数据）
        max-request-size: 100MB
  ```

### 本地存储

- 保存文件

  ```java
  @PostMapping("/upload")
  public Result upload(String name, Integer age, MultipartFile file) throws IOException {
      log.info("接收到的参数值：{},{},{}", name, age, file);
      // 获取原始文件名
      String originalFilename = file.getOriginalFilename();
  
      // 新的文件名
      String extension = originalFilename.substring(originalFilename.lastIndexOf("."));
      String newFileName = UUID.randomUUID().toString() + extension;
  
      //保存文件
      file.transferTo(new File("/uploads/" + newFileName));
      return Result.success();
  }
  ```

### 第三方云服务存储（阿里云OSS）

- 阿里云OSS（Object Storage Service）

- 第三方服务-通用思路

  - 准备工作
  - 参照官方SDK（Software Development Kit），编写入门程序
  - 集成使用

- OSS

  - 注册阿里云 -> 充值 -> 开通对象存储服务OSS -> 创建bucket（用于存储对象的容器）
  - -> 获取并配置AccessKey -> 参照官方SDK编写入门程序
  - 配置AccessKey：

  ```shell
  # windows中配置
  set OSS_ACCESS_KEY_ID=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
  set OSS_ACCESS_KEY_SECRET=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
  # 保存
  echo %OSS_ACCESS_KEY_ID%
  echo %OSS_ACCESS_KEY_SECRET%
  
  # mac中配置
  echo $SHELL
  # bash
  echo "export OSS_ACCESS_KEY_ID='YOUR_ACCESS_KEY_ID'" >> ~/.bash_profile
  echo "export OSS_ACCESS_KEY_SECRET='YOUR_ACCESS_KEY_SECRET'" >> ~/.bash_profile
  source ~/.bash_profile
  # 验证
  echo $OSS_ACCESS_KEY_ID
  echo $OSS_ACCESS_KEY_SECRET
  # zsh
  echo "export OSS_ACCESS_KEY_ID='YOUR_ACCESS_KEY_ID'" >> ~/.zshrc
  echo "export OSS_ACCESS_KEY_SECRET='YOUR_ACCESS_KEY_SECRET'" >> ~/.zshrc
  source ~/.zshrc
  
  echo "export OSS_ACCESS_KEY_ID='******'" >> ~/.zshrc
  echo "export OSS_ACCESS_KEY_SECRET='******'" >> ~/.zshrc
  ```

  - 文件上传案例--看文档

## 参数配置化

- application.yml

```yaml
aliyun:
  oss:
    endpoint: https://oss-cn-beijing.aliyuncs.com
    bucketName: web-learning-tilas
    region: beijing
```

- 使用@Value注解

```java
@Component
public class AliyunOSSOperator {
    @Value("${aliyun.oss.endpoint}")
    private String endpoint;
    @Value("${aliyun.oss.bucketName}")
    private String bucketName;
    @Value("${aliyun.oss.region}")
    private String region;
    ...
}
```

-  @ConfigurationProperties

  - @Value：如果配置项多，注入繁琐，不便于维护管理和复用
  - 使用该注解可以批量封装，需要创建一个实体类（加@Data和@Component）
  - 实体类：

  ```java
  @Data
  @Component
  @ConfigurationProperties(prefix = "aliyun.oss")
  public class AliyunOSSProperties {
      private String endpoint;
      private String bucket;
      private String region;
  }
  ```

  - 使用：

  ```java
  @Component
  public class AliyunOSSOperator {
  rivate String region;*/
      
      @Autowired
      private AliyunOSSProperties aliyunOSSProperties;
  
      public String upload(byte[] content, String originalFilename) throws Exception {
          String endpoint = aliyunOSSProperties.getEndpoint();
          String bucketName = aliyunOSSProperties.getBucket();
          String region = aliyunOSSProperties.getRegion();
          ...
      }
  }
  ```

- 属性较少，用@Value即可

- 属性较多，考虑服用，建议用@ConfigurationProperties

## 异常处理

- 全局异常处理器

  - @RestControllerAdvice = @ControllerAdvice + @ResponseBody
  - @ExceptionHandler

  ```java
  @Slf4j
  @RestControllerAdvice
  public class GlobalExceptionHandler {
  
      @ExceptionHandler
      public Result handleException(Exception e){
          log.error("程序出错了：", e);
          return Result.error("出错了，请联系管理员");
      }
  }
  ```

## 会话技术

- 会话：用户打开浏览器，访问web服务器的资源，会话建立，直到一方断开连接，会话结束。在一次会话中可以包含多次请求和响应
- 会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。
- 会话跟踪方案：
  - 客户端会话跟踪技术：Cookie
  - 服务端会话跟踪技术：Session
  - 令牌技术

### Cookie

- 存储在浏览器本地
- 响应头Set-Cookie；请求头Cookie
- 优点：HTTP协议中支持的技术
- 缺点：
  - 移动端APP无法使用Cookie
  -  不安全，用户可以自己禁用Cookie
  - Cookie不能跨域

### Session

- 底层基于Cookie，只不过存储的是服务器端会话对象Session的ID值 
- 优点：存储在服务端，安全
- 缺点：
  - 服务器集群环境下无法直接使用Cookie
  - Cookie的缺点

### 令牌

- 登陆成功时服务器端生成令牌，客户端存储并在发送请求时携带令牌，服务器端进行校验然后提供服务

- 现在的主流方案

- 优点：

  - 支持PC端、移动端
  - 解决集群环境下的认证问题
  - 减轻服务器端存储压力

- 缺点：

  - 需要自己实现

- JWT令牌

  - 全场：JSON Web Token

  - 定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息

  - 组成

    - 第一部分：Header头，记录令牌类型、签名算法等，如：{"alg":"HS256", "type":"JWT"}
    - 第二部分：Payload有效载荷，携带一些自定义信息、默认信息等，如：{"id":"1", "username":"Tom"}
    - 第三部分：Signature签名，防止Token被篡改，保证安全行。将Header、Payload融入，并加入指定密钥，通过指定签名算法计算而来
    - 前两部分进行了Base64编码

  - 生成/解析

    - 引入jjwt依赖

    ```xml
    <!-- JWT -->
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt</artifactId>
        <version>0.9.1</version>
    </dependency>
    ```

    - 调用官方提供的工具类Jwts来生成或解析jwt令牌

    ```java
    // 生成JWT令牌
    @Test
    public void testGenerateJwt(){
        Map<String, Object> dataMap = new HashMap<>();
        dataMap.put("id", 1);
        dataMap.put("username", "admin");
        String jwt = Jwts.builder().signWith(SignatureAlgorithm.HS256, "d2pr")  // 指定加密算法
                .addClaims(dataMap) // 添加自定义信息
                .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000)) // 设置过期时间
                .compact();// 生成令牌
        System.out.println(jwt);
    }
    
    // 解析JWT令牌
    @Test
    public void testParseJwt(){
        String token = "eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJhZG1pbiIsImV4cCI6MTc2NDI0ODY3M30._hBFmZxLI0H018g9uPJbwhuHOk-ZyPTs4qAUFiXQf5w";
        Claims claims = Jwts.parser()
                .setSigningKey("d2pr") // 指定密钥
                .parseClaimsJws(token) // 解析令牌
                .getBody(); // 获取自定义信息
        System.out.println(claims);
    }
    ```

## 过滤器Filter

### 介绍

- 概念：过滤器，是JavaWeb三个组件（Servlet、Filter、Listener）之一

- 过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能

- 一般完成一些通用的操作，比如：登陆校验、统一编码处理、敏感字符处理等

- 实现

  - 定义Filter：定义一个类，实现Filter接口，并实现其所有方法（init、doFilter、destroy）

  ```java
  @WebFilter(urlPatterns = "/*")  // 拦截所有请求
  public class DemoFilter implements Filter {
      // 初始化方法，web服务器启动的时候执行，只执行一次
      @Override
      public void init(FilterConfig filterConfig) throws ServletException {
          log.info("init 初始化方法 ...");
          Filter.super.init(filterConfig);
      }
  
      // 拦截到请求后执行，会执行多次
      @Override
      public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
          log.info("拦截到了请求");
        	// 放行
          filterChain.doFilter(servletRequest, servletResponse);
      }
  
      // 销毁方法，web服务器关闭的时候执行，只执行一次
      @Override
      public void destroy() {
          log.info("destroy 销毁方法 ...");
          Filter.super.destroy();
      }
  }
  ```

  - 配置Filter：Filter类加@WebFilter注解，配置拦截路径。引导类/启动类上加@ServletComponentScan开启Servlet组件支持
  - 放行：`filterChain.doFilter(servletRequest, servletResponse)`

### 登陆-令牌校验

```java
@WebFilter(urlPatterns = "/*")
public class TokenFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

        // 1.获取请求路径
        String requestURI = request.getRequestURI();

        // 2.判断是否是登陆请求，如果包含/login则是登陆操作，放行
        if (requestURI.contains("/login")){
            log.info("登陆请求，放行");
            filterChain.doFilter(request, response);
            return;
        }

        // 3.获取请求头中的token
        String token = request.getHeader("token");

        // 4.判断token是否存在，如果不存在说明用户没有登陆，返回错误信息（响应401状态码）
        if (token == null || token.isEmpty()){
            log.info("令牌为空，响应401");
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }

        // 5.如果token存在，校验token，如果失败则返回401
        try {
            JwtUtils.parseToken(token);
        } catch (Exception e) {
            log.info("令牌非法，响应401");
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }

        // 6.校验通过，放行
        log.info("令牌合法，放行");
        filterChain.doFilter(request, response);
    }
}
```

### 注意事项

- 执行流程

  - 放行前 --> 放行doFilter --> 资源访问 --> 回到Filter执行doFilter后的代码

- 拦截路径

  | 拦截路径     | urlPatterns值 | 含义                                  |
  | ------------ | ------------- | ------------------------------------- |
  | 拦截具体路径 | /login        | 只有访问 `/login` 路径时，才会被拦截  |
  | 目录拦截     | /emps/*       | 访问 `/emps` 下的所有资源，都会被拦截 |
  | 拦截所有     | /*            | 访问所有资源，都会被拦截              |

- 过滤器链
  - 一个web应用中，可以配置多个过滤器，这多个过滤器就形成了一个过滤器链
  - 顺序：注解配置的Filter，优先级是按照过滤器类名（字符串）的自然排序

## 拦截器 Interceptor

### 介绍

- 概念：是一个动态拦截方法调用的机制，类似于过滤器。是Spring框架中提供的，主要用来动态拦截控制器方法的执行

- 作用：拦截请求，在指定的方法调用前后，根据业务需要执行预先设定的代码

- 实现：

  - 定义拦截器，实现HandlerInterceptor接口，并实现所有方法：
    - preHandle：目标资源方法执行前执行，返回true放行
    - postHandle：目标资源方法执行后执行
    - afterCompletion：视图渲染完毕后执行，最后执行，现在前后端分离已不再需要

  ```java
  @Component
  public class DemoInterceptor implements HandlerInterceptor {
  
      // 目标资源方法运行之前 - 返回值：true 放行，false 不放行
      @Override
      public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
          log.info("preHandle...");
          return true;
      }
  
      // 目标资源方法运行之后
      @Override
      public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
          log.info("postHanlde...");
      }
  
      // 视图渲染完毕后
      @Override
      public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
          log.info("afterCompletion...");
      }
  }
  ```

  - 注册拦截器--定义配置类WebConfig--addInterceptors

  ```java
  // 配置类
  @Configuration
  public class WebConfig implements WebMvcConfigurer {
  
      @Autowired
      private DemoInterceptor demoInterceptor;
  
      @Override
      public void addInterceptors(InterceptorRegistry registry) {
          registry.addInterceptor(demoInterceptor).addPathPatterns("/**"); // 拦截所有请求
      }
  }
  ```

### 注意事项

- 拦截路径

  - addPathPatterns需要拦截的路径
  - excludePathPatterns不需要拦截的路径

  ```java
  public void addInterceptors(InterceptorRegistry registry) {
      registry.addInterceptor(tokenInterceptor)
              .addPathPatterns("/**")  // 拦截所有请求
              .excludePathPatterns("/login");  //不拦截哪些请求
  }
  ```

  | 拦截路径  | 含义                 | 举例                                                         |
  | --------- | -------------------- | ------------------------------------------------------------ |
  | /*        | 一级路径             | 能匹配 `/depts`，`/emps`，`/login`，**不能匹配 `/depts/1`**  |
  | /**       | 任意级路径           | 能匹配 `/depts`，`/depts/1`，`/depts/1/2`                    |
  | /depts/*  | /depts下的一级路径   | 能匹配 `/depts`，**不能匹配 `/depts/1/2`，`/depts`**         |
  | /depts/** | /depts下的任意级路径 | 能匹配 `/depts`，`/depts/1`，`/depts/1/2`，**不能匹配 `/emps/1`** |

- 执行流程

  - 浏览器 --> 过滤器 --> 拦截器 --> 资源访问 --> 拦截器posthHandle --> 过滤器 --> 浏览器

- 区别

  - 过滤器是Servlet规范的接口，拦截器是Spring提供的接口
  - 接口规范不同：过滤器需要实现Filter接口，拦截器需要实现HandlerInterceptor接口
  - 拦截范围不同：过滤器会拦截所有资源，拦截器只会拦截Spring环境中的资源

# Spring AOP

## 概念

- AOP：Aspect Oriented Programming 面向切面/方面编程，可简单理解为面向特定方法编程

  - 场景：案例中部分业务方法运行较慢，定位执行耗时较长的方法，此时需要统计每一个业务方法的执行耗时；记录系统的操作日志；事务管理；权限控制等
  - 优点：可以减少重复代码，对原始代码无侵入，提高开发效率，维护方便
  - AOP是一种思想，Spring框架中对AOP的实现就是SpringAOP

-  实现：如统计所有业务层方法的执行耗时

  - 导入AOP依赖

  ```xml
  <!-- AOP起步依赖 -->
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-aop</artifactId>
  </dependency>
  ```

  - 编写AOP程序：针对特定方法根据业务需要进行编程

  ```java
  @Slf4j
  @Aspect // 标识当前是一个AOP类
  @Component
  public class RecordTimeAspect {
      @Around("execution(* com.itheima.service.impl.*.*(..))")
      public Object recordTime(ProceedingJoinPoint pjp) throws Throwable {
          // 1.记录方法运行的开始时间
          long begin = System.currentTimeMillis();
          // 2.执行原始方法
          Object result = pjp.proceed();
          // 3.记录方法运行的结束时间，记录耗时
          long end = System.currentTimeMillis();
          log.info("方法 {} 执行耗时：{}ms", pjp.getSignature(), end-begin);
  
          return result;
      }
  }
  ```

- 核心概念

  - 连接点：JoinPoint，**可以**被AOP控制等方法（暗含方法执行时的相关信息）
  - 通知：Advice，指那些重复的逻辑，也就是共性功能（最终体现为一个方法）
  - 切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用（**实际**被控制的方法）
    - 切入点一定是连接点，连接点不一定是切入点
  - 切面：Aspect，描述通知与切入点的对应关系（通知+切入点）
  - 目标对象：Target，通知所应用的对象

- 底层是动态代理 

## 通知

- 通知类型

  - @Around：环绕通知，此注解标注的通知方法在目标方法前、后都被执行
    - 需要自己调用 ProceedingJoinPoint.proceed() 来让方法执行，其他通知不需要考虑目标方法执行
    - 返回值必须指定为Object，来接收原始方法的返回值
  - @Before：前置通知，此注解标注的通知方法在目标方法前被执行
  - @After：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行
  - @AfterReturning： 返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行
  - @AfterThrowing ： 异常后通知，此注解标注的通知方法发生异常后执行

- @PointCut

  - 将公共的切入点表达式抽取出来，需要用到时引用该切入点表达式即可

  ```java
  @Pointcut("execution(* com.itheima.service.impl.*.*(..))")
  public void pt(){}
  
  // 前置通知 - 目标方法运行之前运行
  // @Before("execution(* com.itheima.service.impl.*.*(..))")
  @Before("pt()")
  public void before(){
      log.info("before...");
  }
  ```

- 通知顺序

  - 不同切面类中，默认安装切面类的类名字母排序
    - 目标方法前的通知方法，字母排名靠前的先执行
    - 目标方法后的通知方法，字母排名靠前的后执行
  - 用`@Order(数字)`加在切面类上来控制顺序
    - 目标方法前的通知方法，数字小的先执行
    - 目标方法后的通知方法，数字小的后执行

## 切入点表达式

- 描述切入点方法的一种表达式
- 作用：决定项目中的哪些方法需要加入通知
- 常见形式：
  - execution(...) ：根据方法的签名来匹配
    - `execution(访问修饰符? 返回值 包名.类名.?方法名(方法参数) throws 异常?)`
    - 其中带问号的表示可以省略的部分
      - 访问修饰符：可省略（如public、protected）
      - 包名.类名：可省略（不建议省略）
      - throw 异常：可省略（是方法上声明抛出的异常，不是实际抛出的异常）
    - 通配符
      - \* ：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的一个参数，也可以通配包、类、方法名的一部分，如 `* execution(* com.*.service.*.update*(*))`
      - .. ：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数，如：`execution(* com.itheima..DeptService.*(..))`
    - 可以用 &&、||、！逻辑运算符
    - 注意：
      - 业务方法名命名尽量规范
      - 描述切入点方法通常基于接口描述，而不是实现类，增强拓展性
      - 在满足业务需求的前提下，尽量缩小切入点的匹配范围，如包名尽量不用`..`，使用*匹配单个包
      - 是主流使用方式
  - @annotation(...)：根据注解匹配
    - 用于匹配表示有特定注解的方法
    - 如：`@Before("@annotation(com.itheima.anno.LogOperation)")`

## 连接点

- 在Spring中用JoinPoint抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等

  - 对于@Around通知，获取连接点信息只能使用 ProceedingJoinPoint
  - 对于其他四种通知，获取连接点信息只能使用 JoinPoint，它是ProceedingJoinPoint的父类

  ```java
  @Before("execution(* com.itheima.service.*.*(..))")
  public void before(JoinPoint joinPoint){
      // 获取目标对象
      Object target = joinPoint.getTarget();
      // 获取目标类
      String className = target.getClass().getName();
      // 获取目标方法
      String methodName = joinPoint.getSignature().getName();
      // 获取目标方法的参数
      Object[] args = joinPoint.getArgs();
  }
  ```

## 案例-操作日志记录

- 记录增、删、改相关接口的操作日志到数据库表中
- 日志信息包含：操作人、操作时间、执行方法的全类名、执行方法名、方法运行时参数、返回值、方法执行时长
- 通知类型：采用@Around环绕通知
- 切入点表达式：save、delete、update
- 获取当前登录员工信息：解析jwt令牌，使用ThreadLocal传递变量

```java
public class OperateLogAspect {

    @Autowired
    private OperateLogMapper operateLogMapper;

    /**
     * 定义切入点：拦截com.wjk.controller包下的所有方法
     */
    @Pointcut("@annotation(com.wjk.anno.Log)")
    public void controllerMethods() {}

    /**
     * 环绕通知：记录操作日志
     */
    @Around("controllerMethods()")
    public Object recordOperateLog(ProceedingJoinPoint joinPoint) throws Throwable {
        // 获取当前操作人ID（这里假设从SecurityContext或ThreadLocal中获取）
        Integer operateEmpId = getCurrentUserId();
        // 记录开始时间
        long startTime = System.currentTimeMillis();
        Object result = null;
        try {
            // 执行目标方法
            result = joinPoint.proceed();
            return result;
        } finally {
            // 计算执行耗时
            long costTime = System.currentTimeMillis() - startTime;

            // 构建操作日志对象
            OperateLog operateLog = new OperateLog();
            operateLog.setOperateEmpId(operateEmpId);
            operateLog.setOperateTime(LocalDateTime.now());
            operateLog.setClassName(joinPoint.getTarget().getClass().getName());
            operateLog.setMethodName(joinPoint.getSignature().getName());
            operateLog.setMethodParams(Arrays.toString(joinPoint.getArgs()));
            operateLog.setReturnValue(result != null ? result.toString() : "void");
            operateLog.setCostTime(costTime);
            operateLogMapper.insert(operateLog);
        }
    }
}
```

### TreadLocal

- ThreadLocal：并不是一个Thread，而是Thread的局部变量

- ThreadLocal为每个线程提供一份单独的存储空间，具有线程隔离的效果，不同的线程之间不会相互干扰

- 常用方法

  - `public void set(T value)`：设置当前线程的线程局部变量的值
  - `public T get()`：返回当前线程所对应的线程局部变量的值
  - `public void remove()`：移除当前线程的线程局部变量

- 获取员工id

  - 定义ThreadLocal操作的工具类，用于操作当前登录员工id

  ```java
  public class CurrentHolder {
      private static final ThreadLocal<Integer> CURRENT_LOCAL = new ThreadLocal<>();
      public static void setCurrentId(Integer employeeId) {
          CURRENT_LOCAL.set(employeeId);
      }
      public static Integer getCurrentId() {
          return CURRENT_LOCAL.get();
      }
      public static void remove() {
          CURRENT_LOCAL.remove();
      }
  }
  ```

  - 在TokenFilter中，解析完当前登录员工ID，将其存入ThreadLocal（用完之后需要删除）

  ```java
  // 5.如果token存在，校验token，如果失败则返回401
  try {
      Claims claims = JwtUtils.parseToken(token);
      // 将登陆员工id存入ThreadLocal
      Integer empId = Integer.valueOf(claims.get("id").toString());
      CurrentHolder.setCurrentId(empId);
      log.info("当前登录员工ID：{}，将其存入ThreadLocal",empId);
  } catch (Exception e) {
      log.info("令牌非法，响应401");
      response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
      return;
  }
  
  // 6.校验通过，放行
  log.info("令牌合法，放行");
  filterChain.doFilter(request, response);
  
  // 删除ThreadLocal中的数据
  CurrentHolder.remove();
  ```

  - 在AOP程序中，从ThreadLocal中获取当前登录员工的id

  ```java
  private Integer getCurrentUserId() {SecurityContextHolder.getContext().getAuthentication().getPrincipal();
      return CurrentHolder.getCurrentId();
  }
  ```

# SpringBoot原理

## 配置

- springboot中支持三种格式的配置文件：application.properties、application.yaml、application.yml
  - 优先级：properties > yml > yaml
  - 推荐使用同一种格式的配置，yml是主流
- SpringBoot除了支持配置文件属性配置，还支持Java系统属性和命令行参数的方式进行属性配置
  - Java系统属性：如`-Dserver.port=9000`
  - 命令行参数：如`--server.port=10010`
  - IDEA中，在Run/Debug Configurations中，Environment下，有VM options和Program arguments，可以分别设置Java系统属性和命令行参数
  - 运行jar包时，`java [options] -jar <jar 文件> [args...]`，如：`java -Dserver.port=9000 -jar tlias-0.0.1-SNAPSHOT.jar --server.port=10010`
  - 优先级：命令行参数 > Java系统属性 > 配置文件 

## Bean管理

- Bean的作用域

  - `@Scope("prototype")`注解进行设置
  - singleton
    - 默认单例的bean，是在**项目启动时创建**的，创建完毕后将该bean存入IOC容器中
    - 可以延迟创建对象，加注解`@Lazy`，延迟到第一次使用的时候再来创建这个bean
    - **无状态的bean**适用于singleton
      - 没有额外保存数据 -- 无状态的bean，如controller、service、dao
      - 不存在多线程共享数据的问题，是线程安全的
      - 更节约资源（减少创建销毁过程），性能更高
  - prototype
    - 多例的bean
    - **有状态的bean**使用与prototype
      - 额外保存数据的bean -- 有状态的bean
  - 在实际开发中，绝大部分bean都是单例的

  | 作用域        | 说明                                             |
  | ------------- | ------------------------------------------------ |
  | **singleton** | 容器内同名称的 bean 只有一个实例（单例）（默认） |
  | **prototype** | 每次使用该 bean 时会创建新的实例（非单例/多例）  |
  | request       | 每个请求范围内会创建新的实例（web环境中，了解）  |
  | session       | 每个会话范围内会创建新的实例（web环境中，了解）  |
  | application   | 每个应用范围内会创建新的实例（web环境中，了解）  |

- Spring容器中的bean是线程安全的吗

  - bean的线程安全取决于bean的状态及bean 的作用域
  - 单例bean：如果是无状态的bean，内部不会保存任何状态信息，则是线程安全的
  - 单例bean：如果是有状态的bean，内部会保存状态信息，多个线程会同时操作该bean时，可能会出现数据不一致的问题，这样的bean是线程不安全的，设置为多例的则是线程安全的

- 第三方Bean

  - 无法使用@Component及衍生注解声明bean，需要用到@Bean注解

  - 在启动类中**增加一个bean方法**，将方法返回值交给IOC容器管理，成为IOC容器的Bean对象

    - 如果第三方bean需要依赖其他bean对象，直接在bean方法中设置形参即可，容器会根据类型自动装配	
    - 通过@Bean注解的name或value属性可以声明bean的名称，如果不指定，默认bean的名称就是方法名
    - 如：

    ```java
    @SpringBootApplication
    public class SpringbootWebConfigApplication{
        public static void main(String[] args) {
            SpringApplication.run(SpringbootWebConfigApplication.class, args);
        }
        @Bean
        public AliyunOSSOperator aliyunOSSOperator(AliyunOSSProperties aliyunOSSProperties ) {
            return new AliyunOSSOperator(aliyunOSSProperties);
        }
    }
    ```

  - 但是不推荐写在启动类中，而是增加一个配置文件

    ```java
    @Configuration
    public class CommonConfig {
        @Bean
        public AliyunOSSOperator aliyunOSSOperator(AliyunOSSProperties aliyunOSSProperties ) {
            return new AliyunOSSOperator(aliyunOSSProperties);
        }
    }
    ```

## SpringBoot原理

### 起步依赖

- spring-boot-starter-web
- maven的依赖传递

### 自动配置

- SpringBoot的自动配置就是当Spring项目启动后，一些配置类、bean对象就自动存入了IOC容器中，不需要手动声明，简化了开发

- 实现方案

  - 方案一

    - 第三方工具包中有@Component注解
    - 在自己的项目中，使用@ComponentScan注解手动指定组件扫描范围
    - 使用繁琐，性能低

    ```java
    // 自动配置实现方案一
    @ComponentScan(basePackages = {"com.example", "com.itheima"})
    @SpringBootApplication // 具备组件扫描功能，但是默认扫描的是启动类所在包及其子包
    public class SpringbootWebConfigApplication{
        public static void main(String[] args) {
            SpringApplication.run(SpringbootWebConfigApplication.class, args);
        }
    }
    ```

  - 方案二

    - @Import导入。@Import导入的类会被Spring加载到IOC容器中，导入形式有以下三种：
    - 导入【普通类】

    ```java
    // 自动配置实现方案二: @Import
    @Import(TokenParser.class) // 普通类
    @SpringBootApplication 
    public class SpringbootWebConfigApplication{
        public static void main(String[] args) {
            SpringApplication.run(SpringbootWebConfigApplication.class, args);
        }
    }
    ```

    - 导入【配置类】

      - 第三方工具包中增加一个配置类

      ```java
      @Configuration
      public class HeaderConfig {
          @Bean
          public HeaderParser headerParser(){
              return new HeaderParser();
          }
          @Bean
          public HeaderGenerator headerGenerator(){
              return new HeaderGenerator();
          }
      }
      ```

      - 自己的项目中启动类中导入

      ```java
      @Import(HeaderConfig.class) // 配置类
      @SpringBootApplication
      public class SpringbootWebConfigApplication{
          public static void main(String[] args) {
              SpringApplication.run(SpringbootWebConfigApplication.class, args);
          }
      }
      ```

    - 导入【ImportSelector 接口实现类】

      - 第三方工具包中实现ImportSelector接口

      ```java
      public class MyImportSelector implements ImportSelector {
          public String[] selectImports(AnnotationMetadata importingClassMetadata) {
              return new String[]{"com.example.HeaderConfig", "com.example.TokenParser"};
          }
      }
      ```

      - 自己的启动类中导入

      ```java
      @Import(MyImportSelector.class) // ImportSelector实现类 - 批量导入
      @SpringBootApplication
      public class SpringbootWebConfigApplication{
          public static void main(String[] args) {
              SpringApplication.run(SpringbootWebConfigApplication.class, args);
          }
      }
      ```

    - @EnableXxx注解，封装@Import注解

      - 第三方工具包开发人员会提供一个如EnableHeaderConfig的注解，其中包含有@Import注解，如`@Import(MyImportSelector.class)`

      ```java
      @Retention(RetentionPolicy.RUNTIME)
      @Target(ElementType.TYPE)
      @Import(MyImportSelector.class)
      public @interface EnableHeaderConfig {
      }
      ```

      - 在自己的启动类中增加一个注解@EnableHeaderConfig

      ```java
      @EnableHeaderConfig
      @SpringBootApplication
      public class SpringbootWebConfigApplication{
          public static void main(String[] args) {
              SpringApplication.run(SpringbootWebConfigApplication.class, args);
          }
      
      }
      ```

- SpringBoot自动配置

  - 启动类中有@SpringBootApplication，由三部分组成
    - @SpringBootConfiguration：该注解与@Configuration相同，用来声明当前是一个配置类
    - @ComponentScan：组件扫描，默认扫描当前引导类所在包及其子包
    - @EnableAutoConfiguration：SpringBoot实现自动化配置的核心注解
      - @Import(AutoConfigurationImportSelector.class)
  - @Conditional
    - 作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到spring IOC容器中
    - 位置：方法、类
    - 本身是一个父注解，派生出大量子注解
      - @ConditionalOnClass：判断环境中有对应字节码文件，才注册bean到IOC容器中
      - @ConditionalOnMissingBean：判断环境中没有对应的bean（类型或名称），才注册bean到IOC容器中
      - @ConditionalOnProperty ：判断配置文件中有对应属性和值，才注册bean到IOC容器
  - 自己自定义配置类
    - 定义自动配置类
    - 将自动配置类配置在META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports

### 自定义starter

- starter -- 有起步依赖和自动配置的功能

- 场景：在实际开发中，经常会定义一些公共组件，提供各个团队使用。而在SpringBoot项目中，一般将这些公共组件封装为SpringBoot的starter（包含起步依赖和自动配置的功能）

  - spring-boot-starter  依赖管理功能
  - spring-boot-autoconfigure 自动配置功能
  - spring-boot开头的为SpringBoot官方提供的

- 案例

  - 需求：自定义aliyun-oss-spring-boot-starter，完成阿里云oss操作工具类AliyunOSSOperator的自动配置

  - 目标：引入起步依赖后，要使用阿里云OSS，注入AliyunOSSOperator直接使用即可

  - 步骤：

    - 创建aliyun-oss-spring-boot-starter模块
      - 只保留pom文件，只保留spring-boot-starter依赖

    <img src="./images/image-20251207172931536.png" alt="image-20251207172931536" style="zoom:57%;" />

    - 创建aliyun-oss-spring-boot-autoconfigure模块，在starter中引入该模块
      - 在autoconfigure中编写逻辑，编写AutoConfiguration
      - 在starter中引入该模块

    ![image-20251207174050797](./images/image-20251207174050797.png)	

    - 在aliyun-oss-spring-boot-autoconfigure模块中定义自动配置功能，并定义配置文件 META-INFspring/xxx.imports

    ![image-20251207174423653](./images/image-20251207174423653.png)

