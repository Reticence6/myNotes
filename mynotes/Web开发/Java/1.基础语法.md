# 基础语法

## 静态方法

- 属于类，可以**直接用类名访问**：  `类名.静态方法`；可以用对象访问，但不推荐
- 无static修饰的是实例方法，属于对象，只能用对象访问
- 静态方法常见应用场景：**工具类**（如获取验证码）
  - 工具类没有创建对象的需求，建议将构造器私有
  - 直接使用类名调用方法，调用方便，节省内存
- 注意事项
  - 静态方法中可以直接访问静态成员，不可以直接访问实例成员。
  - 实例方法中既可以直接访问静态成员，也可以直接访问实例成员。
  - 实例方法中可以出现this关键字，**静态方法中不可以出现this关键字的**（this代表的是对象）。

## 权限修饰符

- private：只能本类
- 缺省：本类、同一个包中的类
- protected：本类，同一个包中的类、子孙类中
- public：任意类

## 继承

- 特点：
  - 单继承：Java是单继承模式，一个类只能继承一个直接父类
  - 多层继承：Java不支持多继承，但支持多层继承
  - 祖宗类：Java中所有的类都是Object类的子类
  - 就近原则：优先访问自己类中，自己类中的没有才会访问父类（super-访问父类）
- 方法重写
   - 方法名称、形参列表都需一致
   - 用`@Override`注解标注
   - 子类重写父类方法时，访问权限必须大于或者等于父类该方法的权限（public> protected >缺省）
   - 重写的方法返回值类型，必须与被重写方法的返回值类型一样，或者范围更小。
   -  私有方法、静态方法不能被重写，如果重写会报错的。
- **子类构造器先调用父类的构造器**，然后再调用自己的构造器 `super()`
- `this(...)`调用兄弟构造器
   - this、super必须写构造器第一行且不能同时出现

## 多态

- 多态是在继承/实现情况下的一种现象，表现为：对象多态、行为多态
- 方法---编译看左边（父类中有没有），运行看右边（按子类中的运行），但是成员变量都是看的父类的
- 前提：有继承/实现关系；存在父类引用子类对象；存在方法重写。
- 使用多态的好处
  - 在多态形式下，右边对象是解耦合的，更便于扩展和维护
  - 定义方法时，使用父类类型的形参，可以接收一切子类对象，扩展性更强、更便利。

- 多态下会产生的一个问题：**多态下不能使用子类的独有功能**。
  - 类型转换
    -  自动类型转换：父类 变量名=new 子类（）；
    - 强制类型转换：子类 变量名=（子类）父类变量

  - 强制类型转换的注意事项
    - 存在继承/实现关系就可以在编译阶段进行强制类型转换，编译阶段不会报错。
    - 运行时，如果发现对象的真实类型与强转后的类型不同，就会报类型转换异常（ClassCastException）的错误出来。‘
    - 强转前，Java建议：使用`instanceof关键字`，判断当前对象的真实类型，再进行强转。

## 枚举类  Enum

- 枚举类是一个特殊类

- 定义：

  > 修饰符  enum  类名{
  >
  > ​	名称1, 名称2... ;
  >
  > ​	其他成员...
  >
  > }

- 特点

  - 枚举类的第一行，只能写枚举类的对象名称，且要用逗号隔开
  - 这些名称，**本质上是常量，每个常量都记住了枚举类的一个对象**
  - 枚举类都是最终类，**不能被继承**，枚举类都是继承`java.lang.Enum`的
  - 枚举类的构造器都是私有的，因此，枚举类不能对外创建对象
  - 属于多例模式

- 应用场景

  - 适合做信息分类和标志，
  - 比如游戏只有上下左右四个方向，可以用枚举类；
  - 比如divide函数，保留小数的方式，如直接进位RoundingMode.UP/直接舍去.DOWN/四舍五入.HALF/.....

1. 抽象类/抽象方法  Abstract

   - 用abstract修饰的类/方法

     > 修饰符  abstract class 类名{
     >
     > ​	修饰符  abstract  返回值类型   方法名称(形参列表) ;
     >
     > }

   - 特点

     - 抽象类中不一定要有抽象方法，**有抽象方法的类必须是抽象类**
     - 类有的成员：成员变量、方法、构造器，抽象类都可以有
     - **抽象类最主要的特点：抽象类不能创建对象，仅作为一种特殊的父类，让子类继承并实现**
     - 一个类继承抽象类，必须重写完抽象类中的全**部抽象方法**，否则这个类也必须定义为抽象类

   - 应用场景

     - 父类知道每个子类都要做某个行为，但每个子类要做的情况不一样，父类就定义成抽象方法，交给子类去重写实现，我们设计这样的抽象类，就是为了**更好的支持多态**。
     - 模版方法设计模式


## 接口 Interface

- Java提供关键词Interface定义接口

  > public interface 接口名{
  >
  > ​	成员变量（常量）（可以省略 public static final）
  >
  > ​	成员方法（抽象方法）（可以省略 public abstract）
  >
  > }

- JDK 8之前接口中只能定义常量和抽象方法

- 接口**不能创建对象**，接口是用来被类**实现inplements**的，实现接口的类叫做实现类，一个类可同时**实现多个接口**

  > 修饰符   class   类名   implements   接口1， 接口2，....... {
  >
  > ​	// 实现类实现多个接口，必须重写全部接口的全部抽象方法，否则这个类需被定义为抽象类
  >
  > }

- 好处

  - 弥补了单继承的不足，一个类可同时实现多个接口，使类的角色更多，功能更强大
  - 让程序可以面向接口编程，这样程序员就可以灵活方便地切换各种业务实现（更利于程序的解耦合）

- JDK 8后新增了三个方法

  - 默认方法（普通实例方法）：必须用default修饰，默认用public修饰，使用接口的实现类的对象调用
  - 私有方法（JDK9开始）：私有的实例方法，private，使用接口中其他实例方法（默认方法）调用
  - 静态方法：使用static修饰，默认用public修饰，只能使用当前接口名来调用
  - 好处：增强了接口的能力，更便于项目的扩展和维护
  - 项目中基本不用

- 注意事项

  - 接口与接口可以多继承，一个接口可以同时继承多个接口 extends
  - 一个接口继承多个接口，如果多个接口存在方法签名冲突，则此时不支持多继承，也不支持多实现
  - 一个类继承父类，又同时实现了接口，如果父类和接口有同名方法，实现类会优先使用父类的
  - 一个类实现了多个接口，如果多个接口存在同名的默认方法，可以不冲突，这个类重写该方法即可

1. 代码块

   - 类的五大成分：成员变量、构造器、方法、代码块、内部类
   - 静态代码块
     - 格式： `static{}`
     - 特点：**类**加载时自动执行，由于类只会加载一次，所以静态代码块也只会执行一次
     - 作用：完成类的初始化，例如对静态资源的初始化赋值

   - 实例代码块
     - 格式：`{ }`
     - 特点：每次创建**对象**时，执行实例代码块，并在构造器前执行
     - 作用：和构造器一样，都是用来完成对象的初始化的，例如对实例变量初始化


## 内部类

- 如果一个类定义在另一个类的内部，这个类就是内部类

- 场景：当一个类的内部，包含了一个完整的事物，且这个事物没有必要单独设计时，就可以把这个事物设计成内部类。

- 成员内部类

  - 就是类中的一个普通成员，类似前面学过的普通的成员变量、成员方法

  > public class Outer{
  >
  > ​	public class Inner{
  >
  > 
  >
  > ​	}
  >
  > }
  >
  > Outer.Inner inner = new Outer().new Inner();

  - 特点
    - 成员内部类可以直接访问外部类的静态成员，也可以直接访问外部类的实例成员
    - 成员内部类的实例方法中，可以直接拿到当前寄生的外部类的对象：`外部类名.this`

- 静态内部类

  - 有static修饰的内部类，属于外部类自己持有

  > Outer.Inner in = new Outer.Inner();

  - 静态内部类可以直接访问外部类的静态成员，不能直接访问外部类的实例成员

- 局部内部类

  - 定义在方法中、代码块中、构造器等执行体中

- **匿名内部类**

  - 一种特殊的局部内部类，程序员不需要为这个类声明名字，默认有隐藏的名字（外部类名$编号.class）

    > new  类名或接口名 (参数值...) {
    >
    > ​	类体（一般是方法重写）;
    >
    > };
    >
    > 如：
    >
    > Animal a = new Animal(){
    >
    > ​	@Override
    >
    > ​	public void cry(){
    >
    > ​		System.out.println("...");
    >
    > ​	}
    >
    > };

  - 特点：匿名内部类本质就是一个子类，并会立即创建出一个子类对象

  - 作用：用于更方便的创建一个子类对象

  - 常见使用形式：**通常作为一个对象参数传输给方法**

  - 应用场景

    - 调用别人提供的方法实现需求时，这个方法正好可以让我们传输一个匿名内部类对象给其使用。
    - 如点击按钮绑定的监听器
    - 如使用Comparator接口的匿名内部类实现对数据进行排序 


```java
  // 调用API排序
 // public static <T> void sort(T[] a, Comparator<? super T> c)
 // 参数一：需要排序的数组，   参数二：需要给sort方法声明一个比较器对象（制定排序的规则）
 Arrays.sort(students, new Comparator<Student>() {
     @Override
     public int compare(Student o1, Student o2) {
         // 规则： 若左边对象 大于 右边对象，返回正整数
         //       若左边对象 小于 右边对象，返回负整数
         //       若两边相等则返回0
         /*if(o1.getAge() > o2.getAge())
             return 1;
         else if (o1.getAge() < o2.getAge())
             return -1;
         return 0;*/
         // return o1.getAge() - o2.getAge(); // 按年龄升序
         return o2.getAge() - o1.getAge(); // 按年龄降序
     }
 });
```

## 函数式编程

- Lambda表达式

  - 使用Lambda函数替代某些匿名内部类对象，从而让程序更简洁，可读性更好

    > (被重写方法的形参列表) -> {
    >
    > ​	被重写方法的方法体代码
    >
    > }

  - Lambda表达式只能替代函数式接口的匿名内部类（**有且仅有一个抽象方法的接口**）

  ```java
  Arrays.sort(students, (Student o1, Student o2) -> {
          return o2.getAge() - o1.getAge(); // 按年龄降序
      }
  });
  
  Arrays.sort(students, (o1, o2) -> o2.getAge() - o1.getAge());
  ```

  - 进一步简化
    - 参数类型可以全都不写
    - 如果只有一个参数，参数类型省略的同时`()`也可以省略，但是多个参数不能省略`()`
    - 如果Lambda表达式中只有一行代码，大括号可以不写，同时省略分号；如果这行代码是return语句，也必须去掉return

- 方法引用——简化Lambda

  - 静态方法引用

    - `类名::静态方法`
    - 使用场景：如果某个Lambda表达式里只是调用一个静态方法，并且`->`前后参数的形式一致，就可以使用静态方法引用

    ```java
    Arrays.sort(students, (o1, o2) -> Student.compareByAge(o1, o2));
    // 简化
    Arrays.sort(students, Student::compareByAge);
    ```

  - 实例方法引用

    - `对象名::实例方法`
    - 使用场景：如果某个Lambda表达式里只是通过对象名称调用一个实例方法，并且`->`前后参数的形式一致，就可以使用实例方法引用

    ```Java
    Student s = new Student();
    Arrays.sort(students, (o1, o2) -> s.compareByAge(o1, o2));
    // 简化
    Arrays.sort(students, s::compareByAge);
    ```

  -  特定类的方法引用

    - `特定类的名称::方法`
    - 如果某个Lambda表达式里只是调用一个特定类型的实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时就可以使用特定类型的方法引用。

    ```java
    Arrays.sort(names, (o1, o2) -> o1.compareToIgnoreCase(o2));
    // 简化  o1-主调，o2-入参
    Arrays.sort(names, String::compareToIgnoreCase);
    ```

  - 构造器引用

    - `类名::new`
    - 使用场景：如果某个Lambda表达式里只是在创建对象，并且`->`前后参数情况一致，就可以使用构造器引用

    ```java
    class Car{
    	private String name;
    }
    interface CarFactory{
    	Car getCar(String name);
    }
    // main
    CarFactory cf = new CarFactory(){
    		@Override
    		public Car getCar(String name){
    			return new Car(name);
    		}
    };
    Car c1 = cf.getCar("xxx");
    // 简化-Lambda
    CarFactory cf = name -> new Car(name);
    // 简化 构造器引用
    CarFactory cf = Car::new;
    ```


## 常用API--String

- 只要是以双引号方式写出的字符串对象，会存储到**堆内存中的字符串常量池**，且相同内容的字符串**只存储一份**
- 通过new方式创建字符串对象，每new一次都会产生一个新的对象放在**堆内存**里
- 拼接字符串
  - 加号拼接性能差，因为String是不可变对象（共享数据性能好，修改数据性能差）
  - StringBuilder
    - 使用StringBuilder拼接，StringBuilder是可变内容的容量，`sb.append("xxx")`；
    - StringBuilder只是拼接字符串的手段，结果还是要恢复成字符串，`sb.toString()`；
    - StringBuilder支持链式编程，`sb.apend(aaa).apend(bbb).toString()`


# 加强

## 异常

- java.lang.Throwable
  - Error：代表系统级别错误
  - Exception：异常
    - 运行时异常：RuntimeException及其子类
    - 编译时异常
- 基本处理
  - 抛出异常 `throws`：将方法内部出现的异常抛出去给调用者处理
  - 捕获异常` try...catch`： 直接捕获程序出现的异常
- 自定义异常
  - 自定义运行时异常
    - 定义一个异常类继承`RuntimeException`
    - 重写构造器
    - 通过`throw new 异常类(xxx)`来创建异常对象并抛出
    - 特点：编译阶段不报错，运行时才可能出现
  - 自定义编译时异常
    - 定义一个异常类继承`Exception`
    - 重写构造器
    - 通过`throw new 异常类(xxx)`创建异常对象并抛出
    - 特点：编译阶段就报错，提醒比较激进（问题比较严重时使用，最好用运行时异常）
- 处理方案
  - 方案一：底层异常层层往上抛，最外层捕获异常，记录下异常信息，并响应适合用户观看的信息进行提示（最常用）
  - 方案二：最外层捕获异常后，尝试重新修复

## 泛型

- 概念

  - 定义类、接口、方法时，同时声明了一个或者多个类型变量`<E>`，称为泛型类、泛型接口、泛型方法，统称为泛型
  - 作用：提供了编译阶段约束所能操作的数据类型，并自动进行检查的能力。可以避免强制类型转换及其可能出现的异常
  - 本质：把具体的数据类型作为参数传给类型变量

- 泛型类/接口

  > 修饰符   class/interface   类名   <类型变量, 类型变量, ...>  {
  >
  > }
  >
  > 类型变量常用的有 E、T、K、V等

- 泛型方法

  > 修饰符    <类型变量, 类型变量, ...>   返回值类型  方法名（形参列表） {
  >
  > }
  >
  > 如：
  >
  > 修饰符   \<T>   返回值类型  方法名（T[ ] names） {
  >
  > }

  - 通配符
    - 就是`?`，可以在“使用泛型”的时候代表一切类型。E、T、K、V是定义泛型的时候使用
  - 上下限
    - 泛型上限： `? extends Car`，？能接收的必须是Car或者其子类
    - 泛型下限：`? super Car`，？能接收的必须是Car或者其父类

- 泛型支持的类型

  - 不支持基本数据类型，只能支持对象类型（引用数据类型）
  - 泛型擦除：泛型工作在编译阶段，在编译结束后泛型就会被擦除，所有类型都会恢复成Object类型
  - 包装类：把基本类型的数据包装成对象的类型
    - 手工包装，如：`Integer it = Integer.valueOf(100)`（java把-128～127的整数对应的类已经缓存起来了，不用每次都新建类）
    - 自动装箱：`Integer it = 100`，基本数据类型的数据可以直接包装成对象
    - 自动拆箱：`int i = it`，把包装类型的对象直接给基本类型的数据
    - 具备的其他功能
      - 可以把基本类型的数据转化成字符串：`toString`
      - 可以把字符串类型的数值转换成数值本身对应的真实数据类型：`parseInt`,`valueOf`

## 集合

- 是一种容器，用来装数据，大小可变

- Collection-单列集合

  - List\<E>：添加的元素是有序、可重复、有索引的

    - **ArrayList**：基于数组存储数据，根据索引查询数据快、增删效率低
    - LinkedList：基于双链表存储数据，查询慢，增删相对快
      - 新增addFirst、addLast、getFirst、getLast、removeFirst、removeLast
      - 应用：设计队列、栈

  - Set\<E>：添加的元素是无序、不重复、无索引的

    - **HashSet（**无序）：基于哈希表存储数据
      - 哈希值
        - int类型的随机值，每个对象都有一个哈希值
        - Object类的方法返回对象的哈希值：`public int hashCode()`
        - 同一对象的哈希值相同，不同对象的哈希值大概率不同（int类型有范围）
      - 哈希表
        - JDK8之前，哈希表=数组+链表
        - JDK8开始，哈希表=数组+链表+红黑树
        - 哈希表是一种增删改查性能都较好的数据结构
      - 数组元素数量>数组长度(初始16)*加载因子(初始0.75)后，就扩容为原来的两倍
      - JDK8开始，当链表长度超过8，且数组长度>=64时，自动将链表转成红黑树
      - HashSet集合的去重机制
        - 如果希望Set集合认为两个内容一样的不同对象时重复的，必须重写对象的`hashCode()`和`equals()`方法
        - Generate中选择重写这两个方法
    - LinkedHashSet（有序）
      - 基于哈希表（数组、链表、红黑树）实现
      - 但是，每个元素额外的多了一个双链表的机制，记录他前后元素的位置
    - TreeSet（按照大小默认升序排序）
      - 基于红黑树实现的排序
      - 对于数值类型，默认按大小升序排序；对于字符串类型，默认按首字符的编号升序；
      - 对于自定义类型，默认无法排序，需自定义排序规则， 一定要解决，否则会报错
        - 对象类实现Comparable接口，重写compareTo方法，指定大小比较规则
          - `t2.compareTo(t1)`---左边大返回正整数，默认会升序（int的话直接用减法就行，左边-右边，double可以用`Double.compare()`）
        - 重写TreeSet集合自带比较器Comparator对象中的compare方法，制定比较规则

  - 三种遍历方式

    - 迭代器遍历

      - 迭代器是用来遍历集合的专用方式（数组没有迭代器），在Java中迭代器的代表是Iterator
      - `Iterator<E>  iterator()`-返回集合中的迭代器对象，默认指向第一个元素
      - 常用方法：`boolean hasNext()`-询问当前位置是否有元素存在、`E next()`-获取当前位置元素，并同时将迭代器对象指向下一个 元素处

      ```java
      while(it.hasNext()){
      	String name = it.next;
      }
      ```

    - 增强for循环

      ```java
      for(元素的数据类型 变量名：数组或者集合){
      
      }
      ```

    - Lambda表达式

      ```java
      list.forEach(new Consumer<String>(){
      	@Override
      	public void accecpt(String s){
      		System.out.println(s);
      	}
      });
      // 简化
      list.forEach(s -> {
      	System.out.println(s);
      })
      // 再简化  
      list.forEach(System.out::println)
      ```

    - 区别

      - 并发修改异常问题：遍历集合的同时又存在增删集合元素的行为时可能出现业务异常
      - 解决方案：倒着使用索引遍历（支持索引），使用迭代器自己的方法`it.remove()`
      - 第二种和第三种遍历方法都不能解决，只适合做遍历，不适合遍历同时修改

- Map-双列集合

  - `Map<K,V>`也叫键值对集合，键不允许重复，但值可以重复，键和值一一对应

  - HashMap<K, V>：无序、不重复、无索引（由键决定特点）

    - 基于哈希表实现，HashSet用HashMap实现

  - LinkedHashMap<K, V>：有序、不重复、无索引

    - 哈希表+双链表，LinkedHashSet

  - TreeMap<K, V>：按照大小默认升序、不重复、无索引

    - 哈希表+红黑树，TreeSet

  - 遍历方式

    - 键找值

      - 先获取Map集合的全部键，再通过遍历键来找值
      - `keySet()`、`get(key)`

    - 键值对

      - 把键值对看作一个整体进行遍历（难度较大）
      - `Set<Map.Entry<K,V>> entrySet()`--获得所有键值对集合

      ```java
      Set< Map.Entry<String, Double> > entries = map.entrySet();
      for(Map.Entry<String, Double> entry: entries){
      		String key = entry.getKey();
      		double value = entry.getValue();
      		...
      }
      ```

    - Lambda

      - `forEach(BiConsumer<? super K, ? super V> action)`

      ```java
      map.forEach(new BiConsumer<String, Integer>(){
        	@Override
        	public void accept(String key, Integer value){
            	System.out.println(key + "=" + value);
          }
      });
      // 简化
      map.forEach( (k, v)-> {
      		System.out.println(k+ "="+ v);
      });
      ```

## Stream流

- JDK8开始新增的API，可以用于操作集合或数组的数据

- 优势：Stream流大量结合了Lambda的语法风格来编程，功能强大，性能高效，代码简洁，可读性好

- 使用步骤

  - 数据源，获取Stream流（代表一条流水线，并能与数据源建立连接）
  - 调用方法，对数据进行处理、计算
  - 获取处理的结果，遍历/统计/收集到一个新的集合中返回

- 获取Stream流

  - `public interface Stream<T> ..{}`

  - 获取集合的Stream流： 使用Collection提供的`stream()`方法

    ```java
    // collection
    List<String> list = new ArrayList<>();
    Stream<String> s = list.stream();
    // map
    Map<String, Integer> map = new HashMap<>();
    // 获得键流
    Stream<String> s2 = map.keySet().stream();
    // 获得值流
    Stream<Integer> s3 = map.values().stream();
    // 获得键值对流
    Stream< Map.Entry<String, Integer> > s4 = map.entrySet().stream();
    ```

  - 获取数组的Stream流

    - 使用Arrays提供的`stream(T[] array)`方法

    - 使用Stream提供的`of(T... values)`方法 

    ``` java
    String[] names = {...};
    Stream<String> s5 = Arrays.stream(names);
    Stream<String> s6 = Stream.of(names);
    Stream<String> s7 = Stream.of("zhangsan", "lisi", "xxx", "xxx");
    ```

- 中间方法

  - 中间方法指的是调用完成后会返回新的stream流，可以继续使用（支持链式编程）

  - filter过滤、sorted排序、limit获取前几个、skip跳过前几个、distinct去重、map加工元素返回新流、concat合并

    ```java
    Stream<String> s = list.stream().filter(s -> startsWith("张"));
    ```

- 终结方法

  - 终结方法指的是调用完成后，不会返回新stream流，没法继续使用流了

  - forEach遍历、count统计个数

  - max最大值、min最小值 --先返回Optional\<T>对象，然后用get()获取对象

  - 收集stream流：把strean流操作后的结果转回到集合或数组中

    - Stream提供的方法：collect收集到集合中、toArray收集到数组
    - Collections提供具体的收集方式：(static) toList、toSet、toMap

    ```java
    // forEach
    list.stream().filter(s -> startsWith("张")).forEach(System.out::println);
    // max min
    Optional<Teacher> max = teachers.stream().max((t1,t2) -> Double.compare(t1.getSalary(), t2.getSalary()));
    Teacher maxTeacher = max.get();
    // collect  流只能收集一次
    Stream<String> s1 = list.stream().filter(s -> startsWith("张"))
    // List<String> res = s1.collect(Collectors.toList());
    // Set<String> set = s1.collect(Collectors.toSet());
    Object[] array = s1.toArray();
    // collect map
    Stream<Teacher> s2 = teachers.stream();
    Map<String, Double> map = s2.collect(Collectors.toMap(t->t.getName(),t-> t.getSalary()));
    Map<String, Double> map = s2.collect(Collectors.toMap(Teacher::getName, Teacher::getSalary));
    ```

## 方法中可变参数

- 一种特殊的形参，定义在方法、构造器的形参列表，格式是：`数据类型...参数名称`
- 特点：可以不穿数据给它；可以传一个/同时传多个数据给它；也可以传一个数组
- 好处：常用来灵活接收数据
- 注意事项：
  - 可变参数在方法内部就是一个数组
  - 一个形参列表只能有一个可变参数
  - 可变参数必须放在形参列表的**最后**

## Collections工具类

- 操作集合的工具类
- addAll--批量加数据，shuffle--打乱list的顺序，sort--对list升序排序

## File、IO流

- 存储数据的方案：变量、数组、对象、集合（都在内存中）、文件（磁盘）
- **File类：只能对文件本身进行操作，不能读写文件里面存储的数据**
- **IO流：用于读写数据的**（文件或网络中的数据）

###  File

- File类的对象可以代表文件/文件夹，并可以调用其提供的方法对文件操作

- 创建File类的对象

  - **`public File(String pathname)` ：常用**
  - `public File(String parent, String child)` ：根据父路径和子路径名字创建文件对象
  - `public File(File parent, String child)`：根据父路径对应文件对象和子路径名创建对象
  - File封装的对象仅仅是一个路径名，这个路径可以是存在的，也允许是不存在的

- 常用方法

  - exists-存在，isFile-是否是文件，isDirectory-是否是文件夹
  - getName-获取文件名称，length-文件大小（字节个数），lastModified
  - getPath-创建文件时使用的路径，getAbsolutePath-绝对路径
  -  创建：createNewFile文件、mkdir一级文件夹、mkdirs多级文件夹
  - 删除文件：delete-默认只能删文件或者空文件夹
  - 遍历文件夹：list-获取一级文件名称(String[ ])、listFiles-获取一级文件对象(File[ ])
  - 使用listFiles的注意事项
    - 当主调是文件或者路径不存在时，返回null
    - 当主调是空文件夹时，返回一个长度为0的数组
    - **当主调是一个有内容的文件夹时，将里面所有的一级文件和文件夹的路径放在File数组中**
    - 当主调是一个文件夹，且里面有隐藏文件夹时，隐藏文件也会包含在内
    - 当主调是一个文件夹，但没有权限访问时，返回null

- 文件搜索

  - 方法递归：从形式上，方法调用自身的形式称为方法递归
  - 搜索文件，返回其位置

  ```java
  public void searchFile(File dir, String fileName){
  	// 判断极端情况
  	if(dir==null || !dir.isExist() || dir.isFile())
  		return;
    // 获取目录下的所有一级文件或文件夹
    File[] files = dir.listFiles();
    // 遍历一级文件对象
    if(files!=null && files.length>0){
    		for(File file: files){
    				if(file.isFile()){
    						if(file.getName().contains(fileName)){
                		System.out.println(file.getAbsolutePath);
                  	// 如果是程序，可以用虚拟机运行程序
                  	Runtime r = Runtime.getRuntime();
                  	r.exec(file.getAbsolutePath);
                }
    				}else{
    						searchFile(file, fileName);
    				}
    		}
    }
  }
  ```

### IO流

- 按照流分为输入流和输出流，按流的内容分为字节流(各种文件)和字符流(只适合文本文件)

- 字节输入流InputStream--实现类FileInputStream

  - 把文件的数据以字节的形式读入到内存
  - 构造器：`FileInputStream(File file)` 、`FileInputStream(String pathname)`
  - 方法：`public int read()`-每次读一个字节、`public int read(byte[] buffer)`-每次用一个字节数组读取数据，没有数据返回-1

  ```java
  // InputStream input = new FileInputStream(new File("xxx.txt"));
  InputStream input = new FileInputStream("xxx.txt");
  // 每次读一个字节
  // 性能差，且读汉字会乱码
  int b;
  while((b = input.read()) != -1){
  		System.out.print((char)b);
  }
  // 每次读多个字节
  // 定义一个字节数组用于每次读取的数据
  byte[] buffer = new byte[1024];
  // 定义一个变量记录读取的字节数
  int len;
  while((len = input.read(buffer)) != -1){
    	String str = new String(buffer);
    	System.out.println(str);
  }
  // 仍无法避免中文输出乱码
  
  // 一次读全部字节
  byte[] bytes = input.readAllBytes();
  String str = new String(bytes);
  System.out.println(bytes);
  
  input.close();
  ```

  - 解决中文乱码
    - 一次读取完所有字节`public byte[] readAllBytes()`，适合读小文件

- 字节输出流OutputStream--FileOutputStream

  - 把内存中的数据以字节的形式写出到文件中
  - 构造器：`FileOutputStream(File file)`、`FileOutputStream(String filepath)`、`FileOutputStream(File file, boolean append)`、`FileOutputStream(String filepath, boolean append)`，append-是否追加数据
  - 方法：`write(int a)`、`write(byte[] buffer)`、`write(byte[] buffer, int pos, int len)`、`close()`

  ```java
  // 创建管道
  OutputStream os = new FileOutputStream("basics/src/com/wjk/filelearning/2.txt",true);
  // 写入数据
  // 写一个字节
  os.write(97);
  os.write('b');
  //os.write('徐'); // 会乱码
  // \r\n--换行，多平台兼容
  os.write("\r\n".getBytes());
  // 写一个字节数组
  byte[] bytes = "我爱你dadssd\r\n".getBytes();
  os.write(bytes);
  // 写一个字节数组的一部分
  os.write(bytes, 0, 3);
  //关闭管道，释放资源
  os.close();
  ```

  - 字节流非常适合做文件的复制操作

  ```java
  public static void copyFile(String srcPath, String destPath) throws Exception{
      InputStream fis = new FileInputStream(srcPath);
      OutputStream fos = new FileOutputStream(destPath);
  
      byte[] buffer = new byte[1024];
      int len;
      while ((len = fis.read(buffer)) != -1){
          fos.write(buffer, 0, len);
      }
    	fos.close();
    	fis.close();
  }
  ```

- 资源释放问题

  - try -catch-finally
    - 无论是否异常，最后一定要执行finally区，除非JVM终止
    - 一般用于程序执行完成后进行资源的释放操作

  ```java
  public static void copyFile(String srcPath, String destPath) throws Exception{
        InputStream fis = null;
        OutputStream fos = null;
        try {
            fis = new FileInputStream(srcPath);
            fos = new FileOutputStream(destPath);
  
            byte[] buffer = new byte[1024];
            int len;
            while ((len = fis.read(buffer)) != -1){
                fos.write(buffer, 0, len);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if(fos != null)
                    fos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
  
            try {
                if(fis != null)
                    fis.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
  
    }
  ```

  - try -with-resource
    - try(定义资源1; 定义资源2; ...)
    - 括号里只能放资源（资源一般指的是最终实现了AutoCloseable/Closeable接口的类或接口）
    - 会自动调用close

  ```java
  public static void copyFile(String srcPath, String destPath) throws Exception{
      try(
              InputStream fis = new FileInputStream(srcPath);
              OutputStream fos = new FileOutputStream(destPath);
              ) {
          byte[] buffer = new byte[1024];
          int len;
          while ((len = fis.read(buffer)) != -1){
              fos.write(buffer, 0, len);
          }
      } catch (Exception e) {
          e.printStackTrace();
      }
  }
  ```

- 字符输入流Reader--FileReader

  - 把文件的数据以字符的形式读入到内存
  - 构造器：`FileReader(File file)`  `FileReader(String pathname)`
  - 方法：`read()`   `read(char[] buffer)`
  - 每次读多个字符性能较好，中文不会出现乱码

  ```java
  try (Reader fr = new FileReader("basics/src/com/wjk/filelearning/1.txt")) {
      // 定义一个字符数组，每次读多个字符
      char[] chs = new char[1024];
      int len;
      while( (len = fr.read(chs)) != -1){
          String str = new String(chs, 0, len);
          System.out.println(str);
      }
  }catch (Exception e){
      e.printStackTrace();
  }
  ```

- 字符输出流Writer--FileWriter

  - 把内存中的数据以字符的形式写到文件中
  - 构造器：`FileWriter(File file)`、`FileWriter(String filepath)`、`FileWriter(File file, boolean append)`、`FileWriter(String filepath, boolean append)`，append-是否追加数据
  - 方法：`write(int c)`、`write(String str)`、`write(String str, int off, int len)`、`writer(char[] cbuf)`、 `writer(char[] cbuf, int off, int len)`
  - 字符输出流写出数据后，必须刷新流或者关闭流，写出的数据才能生效：`flush()`  `close()`（内存缓冲区）

  ```java
  try (Writer fw = new FileWriter("basics/src/com/wjk/filelearning/4.txt", true)) {
    // 写一个字符
    fw.write('a');
    fw.write(98);
    fw.write('我');
    fw.write("\r\n");
  
    // 写一个字符串
    fw.write("我java");
    fw.write("java", 1, 2);
    fw.write("\r\n");
  
    // 写一个字符数组
    char[] chars = "java".toCharArray();
    fw.write(chars);
    fw.write(chars,1, 2);
    fw.write("\r\n");
  
    // 刷新缓冲区，将缓冲区中的数据全部写出去，刷新后，流可以继续使用
    fw.flush();
    // 关闭资源，关闭包含了刷新，关闭后流不能继续使用，所以也一般不用写刷新
    // fw.close();
  
  }catch (Exception e){
    e.printStackTrace();
  }
  ```

- 缓冲流

  - 提高流读写的性能

  - 缓冲字节输入流 BufferedInputStream、缓冲字节输出流 BufferedOutputStream

    - 可以提高字节输入流/输出流的性能
    - 默认**8KB**的缓冲池，把数据读到缓冲池，字节数组再从缓冲池中读取数据；输出流同理，先写到缓冲池，满了后写入磁盘
    - `BufferedInputStream(InputStream is)`
    - `BufferedOutputStream(OutputStream os)`

    ```java
    public static void copyFile(String srcPath, String destPath) throws Exception{
        try(
                // 把低级的字节输入/出流包装成高级的缓冲字节输入/出流
                InputStream fis = new FileInputStream(srcPath);
                InputStream bis = new BufferedInputStream(fis);
                OutputStream fos = new FileOutputStream(destPath);
                OutputStream bos = new BufferedOutputStream(fos);
                ) {
            byte[] buffer = new byte[1024];
            int len;
            while ((len = bis.read(buffer)) != -1){
                bos.write(buffer, 0, len);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    ```

  - 缓冲字符输入流 BufferedReader、缓冲字符输出流 BufferedWriter

    - 自带**8K**的字符缓冲池，提高字符输入流/输出流的性能
    - `BufferedReader(Reader r)`，新增`readLine()`按行读的功能

    ```java
    try (
        Reader fr = new FileReader("basics/src/com/wjk/filelearning/3.txt");
        BufferedReader br = new BufferedReader(fr);
    ) {
        String line;
        // line = br.readLine();
        while ((line = br.readLine()) != null){
            System.out.println(line);
        }
    }catch (Exception e){
        e.printStackTrace();
    }
    ```

    - `BufferedWriter(Writer w)`，新增`newLine()`换行功能

    ```java
    try (
            Writer fw = new FileWriter("basics/src/com/wjk/filelearning/4.txt", true);
            BufferedWriter bw = new BufferedWriter(fw);
    ) {
        // 写一个字符串
        bw.write("我java");
        bw.write("java", 1, 2);
        bw.newLine();
    }catch (Exception e){
        e.printStackTrace();
    }
    ```

- 性能分析

  ```java
  // 使用低级的字节流按照一个一个字节的形式复制文件  太慢了，不要使用 4
  // copyFileByByte();
  // 使用低级的字节流按照字节数组的形式复制文件  有一点慢 2
  copyFileByByteArray();
  // 使用高级的缓冲字节流按照一个字节一个字节的形式复制文件  比较慢 3
  copyFileByBufferedByte();
  // 使用高级的缓冲字节流按照字节数组的形式复制文件  非常快 1
  copyFileByByteArray();
  ```

- 其他流

  - 字符输入转换流 InputStreamReader
    - 解决不同编码时，字符流读取文本内容乱码的问题
    - 解决思路：先获取文件的原始字节流，再将其按真实的字符集编码转成字符输入流，这样字符输入流中的字符就不乱码了
    - 构造器：`InputStreamReader(InputStream is)`  `InputStreamReader(InputStream is, String charset)`  
  - 打印流 PrintStream  PrintWriter
    - 更方便、更高效的打印数据出去，能实现打印啥出去就是啥出去
    - 常用构造器：`PrintStream(OutputStream/File/String)`
    - 常用方法：`println()` 打印任意类型的数据出去
  - 特殊数据流 DataInputStream  DataOutputStream（做通信时使用）
    - DataOutputStream
      - 允许把数据和其类型一并写出去
      - 构造器：`DataOutputStream(OutputStream out)`
        - 方法：`writeByte(int v)`, `writeInt(int v)`, `writeDouble(Double v)`, `writerUTF(String str)`
    - DataInputStream同理

- IO框架

  - commons-io：apache开源的一组有关io操作的框架，目的是提高IO流的开发效率
  - 放入lib文件夹下，再右键点击`Add as Library`
  - 其中FileUtils类的部分方法 
    - `copyFile(File srcFile, File destFile)`   `copyDirectory()`
    - `deleteDirectory(File dir)` 
    - `readFileToString(File file, String encoding)`
    - `writeStringToFile(File file, String data, String charname, boolean append)`
  - 其中IOUtils类的部分方法
    - `copy(InputStream is, OutputStream os)`
    - `copy(Reader r, Writer w)`
    - `write(String data, OutputStream output, String chasetName)`

![image-20251015205907052](./images/image-20251015205907052.png)

## 多线程

线程：一个程序内部的一条执行流程

多线程：从 软硬件上实现的多条执行流程的技术（由CPU负责调度执行）

### 创建方式

1. 继承Thread类

   - 步骤：
     - 定义子类继承Thread，重写run方法
     - 创建子类的对象
     - 调用线程对象的start方法启动线程
   - 优点：编码简单
   - 缺点：线程类已继承Thread类，无法继承其他类，不利于功能的扩展
   - 注意：
     - 启动线程必须调用start，而不是run
       - 直接调用run会当成普通方法执行，此时还是单线程执行
       - 只有start方法才是启动一个新的线程执行
     - 不要把主线程任务放在启动子线程之前

   ```java
   public class ThreadCreate1 {
       // main方法本身是由一条主线程负责推进执行的
       public static void main(String[] args) {
           // 创建线程方式一：继承Thread类
           // 4.创建线程类的对象代表现场
           Thread t1 = new MyThread();
           // 5.调start方法，启动线程
           t1.start();
   
           for (int i = 0; i < 5; i++) {
               System.out.println("主线程输出：" + i);
           }
       }
   }
   
   // 1.定义子类继承Thread
   class MyThread extends Thread{
       // 2.重写run方法
       @Override
       public void run() {
           // 3.在run中编写线程的任务代码
           super.run();
           for (int i = 0; i < 5; i++) {
               System.out.println("子线程输出：" + i);
           }
       }
   }
   ```

2. 实现Runnable接口

   - 步骤：
     - 定义一个线程任务类继承Runnable接口，重写run方法
     - 创建线程任务对象
     - 把线程任务对象交给Thread处理
   - 优点：任务类只是实现接口，可以继承其他类，实现其他接口，扩展性强
   - 缺点：需要多一个Runnable对象

   ```java
   public class ThreadCreate2 {
       public static void main(String[] args) {
           // 多线程创建方式二：实现Runnable接口
           // 3.创建线程任务类的对象代表一个线程任务
           Runnable r = new MyRunnable();
           // 4.把线程任务对象交给一个线程对象来处理
           Thread t = new Thread(r);
           // 5.启动线程
           t.start();
   
           for (int i = 0; i < 5; i++) {
               System.out.println("主线程输出：" + i);
           }
       }
   }
   
   // 1.定义一个线程任务类实现Runnable接口
   class MyRunnable implements Runnable{
       // 2.重写run方法
       @Override
       public void run() {
           for (int i = 0; i < 5; i++) {
               System.out.println("子线程输出：" + i);
           }
       }
   }
   ```

   - 匿名内部类的写法

   ```java
   new Thread(new Runnable() {
       @Override
       public void run() {
           for (int i = 0; i < 5; i++) {
               System.out.println("子线程输出：" + i);
           }
       }
   }).start();
   // 简化
   new Thread(() -> {
       for (int i = 0; i < 5; i++) {
           System.out.println("子线程输出：" + i);
       }
   }).start();
   ```

3. 实现Callable接口和FutureTask类

   - 前两种创建方式的问题：假如线程执行完毕后要返回数据，run方法不能直接返回结果
   - 步骤：
     - 创建任务对象
       - 定义一个类实现Callable接口，重写call方法，封装要做的事和返回的数据
       - 把Callable类型的对象封装成FutureTask（线程任务对象）
     - 把线程任务对象交给Thread对象，调用start启动线程
     - 线程执行完毕后，通过FutureTask对象的get方法获取线程任务执行的结果
   - 优点：线程任务类只是实现接口，可以继承类和实现接口， 扩展性强；可以在线程执行完毕后获取线程执行的结果
   - 缺点：编码复杂一点

   ```java
   public class ThreadCreate3 {
       public static void main(String[] args) {
           // 线程创建方式三：实现Callable接口和FutureTask对象  优势：可以获取线程执行完毕后的结果
           // 3.创建一个Callale接口的实现类对象
           Callable<String> c1 = new MyCallable(100);
           // 4.把Callable对象封装成一个真正的线程任务对象-FutureTask对象
           //      作用：本质是一个Runnable-线程任务对象，可以交给Thread线程对象处理
           //           可以获取线程执行完毕后的结果
           FutureTask<String> f1 = new FutureTask<>(c1);
           // 5.创建Thread对象
           Thread t1 = new Thread(f1);
           t1.start();
   
           Callable<String> c2 = new MyCallable(50);
           FutureTask<String> f2 = new FutureTask<>(c2);
           Thread t2 = new Thread(f2);
           t2.start();
   
           // 取线程的结果
           try {
               // 如果主线程发现第一个线程还没有执行完毕，则会让出CPU，等第一个线程执行完毕后，才会往下执行
               System.out.println(f1.get());
           } catch (Exception e) {
               e.printStackTrace();
           }
           try{
               System.out.println(f2.get());
           } catch (Exception e) {
               e.printStackTrace();
           }
   
       }
   }
   
   // 1.定义一个实现类实现Callable接口
   class MyCallable implements Callable<String>{
       private int n;
       public MyCallable(int n) {
           this.n = n;
       }
       // 重写call方法
       @Override
       public String call() throws Exception {
           int sum = 0;
           for (int i = 1; i <= n; i++) {
               sum += i;
           }
           return "子线程计算1-" + n + "的和是：" + sum;
       }
   }
   ```

### 常用方法

- Thread提供的常用方法

| 方法签名                               | 说明                                          |
| -------------------------------------- | --------------------------------------------- |
| `public void run()`                    | 线程的任务方法                                |
| `public void start()`                  | 启动线程                                      |
| `public String getName()`              | 获取当前线程的名称，线程名称默认是Thread-索引 |
| `public void setName(String name)`     | 为线程设置名称                                |
| `public static Thread currentThread()` | 获取当前执行的线程对象                        |
| `public static void sleep(long time)`  | 让当前执行的线程休眠多少毫秒后，再继续执行    |
| `public final void join()...`          | 让调用当前这个方法的线程先执行完！            |

- Thread提供的常见构造器

| 构造器签名                                    | 说明                                         |
| --------------------------------------------- | -------------------------------------------- |
| `public Thread(String name)`                  | 可以为当前线程指定名称                       |
| `public Thread(Runnable target)`              | 封装Runnable对象成为线程对象                 |
| `public Thread(Runnable target, String name)` | 封装Runnable对象成为线程对象，并指定线程名称 |

### 线程同步

- 多个线程同时操作一个共享资源时，可能会出现业务安全问题
- 线程同步是线程安全问题的解决方案
- 核心思想：多个线程先后依次访问共享资源，就可以避免出现线程安全问题
- 常见方案：加锁--每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动解锁，然后其他线程才能再加锁进来

1. 方式一：同步代码块

   - 把**访问共享资源的核心代码**上锁，保证线程安全
   - 注意：对于当前同时执行的线程来说，同步锁必须是同一把（同一个对象），否则会出bug
   - 锁对象
     - **建议使用共享资源作为锁对象**，对于实例方法建议用**this**作为锁对象
     - 对于静态方法建议用**字节码（类名.class）**对象作为锁对象

   ```java
   public void drawMoney(double money) {
       // 拿到当前谁来取钱
       String name = Thread.currentThread().getName();
       // 判断余额是否足够
       // 同步代码块  用对象代表锁，对于线程来说是唯一对象
       synchronized (this) {
           if (this.money >= money) {
               // 取钱
               System.out.println(name + "取钱成功，取钱金额：" + money + "元");
               this.money -= money;
               System.out.println(name + "取钱成功，余额：" + this.money + "元");
           } else {
               // 余额不足
               System.out.println(name + "取钱失败，余额不足");
           }
       }
   }
   ```

2. 方式二 ：同步方法

   - 把访问共享资源的**核心方法**上锁，保证线程安全，方法前加一个`synchronized`即可
   - 底层原理
     - 底层也是有隐式锁对象的，只是锁的范围是整个方法代码
     - 如果是实例方法：同步方法默认用**this**作为锁的对象
     - 如果是静态方法：同步方法默认用**类名.class**作为锁的对象
   -  同步方法和同步代码块比较
     - 范围上：同步代码块锁的范围更小，同步方法锁的范围更大
     - 可读性：同步方法可读性更好

   ```java
   public synchronized void drawMoney(double money) {
       String name = Thread.currentThread().getName();
       if (this.money >= money) {
           // 取钱
           System.out.println(name + "取钱成功，取钱金额：" + money + "元");
           this.money -= money;
           System.out.println(name + "取钱成功，余额：" + this.money + "元");
       } else {
           // 余额不足
           System.out.println(name + "取钱失败，余额不足");
       }
   }
   ```

3. 方式三：Lock锁

   - Lock锁是JDK5开始提供的一个新的锁定操作，通过它可以创建锁对象进行加锁和解锁，更灵活、方便、强大
   - Lock是接口，不能直接实例化，可以用它的实现类ReentrantLock来构建Lock锁对象
   - 常用方法：`void lock()` -获得锁、`void unlock()`-释放锁

   ```java
   // 在类中直接定义一个lock锁对象
   private final Lock lk = new ReentrantLock(); // final-保护锁对象
   // 方法
   public void drawMoney(double money) {
           // 拿到当前谁来取钱
           String name = Thread.currentThread().getName();
           lk.lock();
           try {
               // 判断余额是否足够
               if (this.money >= money) {
                   // 取钱
                   System.out.println(name + "取钱成功，取钱金额：" + money + "元");
                   this.money -= money;
                   System.out.println(name + "取钱成功，余额：" + this.money + "元");
               } else {
                   // 余额不足
                   System.out.println(name + "取钱失败，余额不足");
               }
           } finally {
               lk.unlock();
           }
       }
   ```

### 线程池

- 线程池是一个可以复用线程的技术
- 不使用线程池的问题：用户每发起一个请求，后台就要创建一个新线程处理，下次新任务来了还要创建线程。创建新线程的开销很大，并且请求过多时，会产生大量的线程，严重影响系统的性能
- 工作原理
  - 工作线程 WorkThread
  - 任务队列 Work Queue（只能处理Runnable和Callable任务对象）

#### 创建线程池

- 线程池接口：ExecutorService

- 方式一：使用ExecutorService的实现类ThreadPoolExecutor创建一个线程池对象

  ```java
  // 使用指定的初始化参数创建一个新的线程池对象
  public ThreadPoolExecutor(int corePoolSize, 
                            int maximumPoolSize, 
                            long keepAliveTime, 
                            TimeUnit unit, 
                            BlockingQueue<Runnable> workQueue, 
                            ThreadFactory threadFactory, 
                            RejectedExecutionHandler handler)
  ```

  - 参数一：`corePoolSize`：指定线程池的核心线程的数量
  - 参数二：`maximumPoolSize`：指定线程池的最大线程数量
  - 参数三：`keepAliveTime`：指定临时线程的存活时间
  - 参数四：`unit`：指定临时线程存活的时间单位(秒、分、时、天)
  - 参数五：`workQueue`：指定线程池的任务队列
  - 参数六：`threadFactory`：指定线程池的线程工厂（负责创建线程工程）
  - 参数七：`handler`：指定线程池的任务拒绝策略（线程都在忙，任务队列也满了的时候，新任务来了该怎么处理）

  ```java
  // 使用线程池的实现类ThreadPoolExecutor声明七个参数来创建线程池对象
  // ArrayBlockingQueue<Runnable> workQueue, LinkedBlockingQueue<Runnable> workQueue,
  ExecutorService pool = new ThreadPoolExecutor(3, 5,
          10, TimeUnit.SECONDS,
          new ArrayBlockingQueue<>(3),
          Executors.defaultThreadFactory(),
          new ThreadPoolExecutor.AbortPolicy());
  ```

  - 常用方法
    - `void execute(Runnable command)` 执行Runnable任务
    - `Future<T> submit(Callable<T> task)` 执行Callable任务，返回未来任务对象，用于获取线程返回的结果
    - `void shutdown()` 等全部任务执行完毕后，关闭线程池
    - `List<Runnable> shutdownNow()` 立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务

  ```java
  // 使用线程池处理任务，看会不会复用线程
  // 处理Runnable任务
  Runnable target = new MyRunnable();
  pool.execute(target); // 提交第一个任务  创建第一个线程 自动启动线程处理这个任务
  pool.execute(target); // 提交第二个任务  创建第二个线程 自动启动线程处理这个任务
  pool.execute(target); // 提交第三个任务  创建第三个线程 自动启动线程处理这个任务
  pool.execute(target); // 复用线程
  pool.execute(target); // 复用线程
  pool.execute(target);
  pool.execute(target); // 到了创建临时线程的时机
  pool.execute(target);
  pool.execute(target); // 任务拒绝策略
  
  // 关闭线程池：一般不关闭线程池
  // pool.shutdown(); // 等所有任务执行完毕后关闭
  // pool.shutdownNow(); // 立即关闭
  
  // 处理Callable任务
  Future<String> f1 = pool.submit(new MyCallable(100));
  Future<String> f2 = pool.submit(new MyCallable(200));
  Future<String> f3 = pool.submit(new MyCallable(300));
  Future<String> f4 = pool.submit(new MyCallable(400));
  
  try {
      System.out.println(f1.get());
      System.out.println(f2.get());
      System.out.println(f3.get());
      System.out.println(f4.get());
  } catch (Exception e) {
      e.printStackTrace();
  }
  ```

  - 注意事项
    - 新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程
    - 核心线程和临时线程都在忙，任务队列也满了，新的任务来时才会拒绝新任务
    - 任务拒绝策略
      - `ThreadPoolExecutor.AbortPolicy()`  丢弃任务并抛出RejectedExecutionException异常（默认策略）
      - `ThreadPoolExecutor.DiscardPolicy()` 丢弃任务，但不抛出异常，不推荐
      - `ThreadPoolExecutor.DiscardOldestPolicy()` 抛弃队列中等待最久的任务，然后把当前任务加入队列中
      - `ThreadPoolExecutor.CallerRunsPolicy()` 由主线程负责调用任务的run()方法从而绕过线程池直接执行   
    - 核心线程数
      - 对于CPU密集型任务，线程池的大小通常设置为与系统可用处理器数量相等或稍多一点
      - 对于IO密集型任务，线程可能大部分时间在等待IO操作，此时可以设置更多的线程来充分利用CPU

- 方式二：使用Excetors（线程池的工具类）调用方法返回不同特点的线程池对象
  - 静态方法创建线程池
    - `public static ExecutorService newFixedThreadPool(int nThreads)`  创建固定线程数量的线程池，如果某个线程因执行异常而结束，那么线程池会补充一个新线程替代它
    - `public static ExecutorService newSingleThreadExcutor()` 创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程
    - `public static ExecutorService newCachedThreadPool(int nThreads)`   线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了60s则会被回收掉
    - `public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)` 创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务 
  - 大型并发系统环境中使用Executors如果不注意可能会出现系统风险
    - FixedThreadPool 和 SingleThreadPool
      - 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。
    - CachedThreadPool 和 ScheduledThreadPool
      - 允许的创建线程数量 Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。

## 网络编程

可以让设备中的程序与网络上其他设备中的程序进行数据交互的技术

### 基本的通信架构

- C/S架构：客户端/服务端
- B/S架构：浏览器/服务端

### 网络编程三要素

- IP：设备在网络中的唯一标识

  - IPv4：32位，点分十进制
  - IPv6：128位，冒号分十六进制
  - 域名：DNS域名解析
  - 公网IP和内网IP
  - 本机IP：127.0.0.1/localhost
  - InetAddress：java中的IP地址表示方法

  | InetAddress类的常用方法                                      | 说明                                           |
  | ------------------------------------------------------------ | ---------------------------------------------- |
  | `public static InetAddress getLocalHost() throws UnknownHostException` | 获取本机IP，返回一个InetAddress对象            |
  | `public String getHostName()`                                | 获取该ip地址对象对应的主机名。                 |
  | `public String getHostAddress()`                             | 获取该ip地址对象中的ip地址信息。               |
  | `public static InetAddress getByName(String host) throws UnknownHostException` | 根据ip地址或者域名，返回一个InetAddress对象    |
  | `public boolean isReachable(int timeout) throws IOException` | 判断主机在指定毫秒内与该ip对应的主机是否能连通 |

- 端口：应用程序在设备中的唯一标识

  - 16位二进制，0～65535
  - 周知端口0～1023：被预先定义的知名应用占用
  - 注册端口1024～49151：分配给用户进程或某些应用程序
  - 动态端口49152～65536：一般不固定分配某种进程，而是动态分配
  - 自己开发的程序一般选择使用注册端口，且一个设备中不能出现两个程序的端口号一样，否则报错

- 协议：连接和数据在网络中传输的规则

  - OSI网络参考模型
  - TCP/IP网络协议 
  - UDP、TCP

### UDP通信

- 无连接、不可靠
- `java.net.DatagramSocket类`实现UDP通信
- DatagramSocket：创建客户端、服务端

| 构造器签名                        | 说明                                               |
| --------------------------------- | -------------------------------------------------- |
| `public DatagramSocket()`         | 创建客户端的Socket对象，系统会随机分配一个端口号。 |
| `public DatagramSocket(int port)` | 创建服务端的Socket对象，并指定端口号               |

- 方法：

| 方法签名                                | 说明               |
| --------------------------------------- | ------------------ |
| `public void send(DatagramPacket dp)`   | 发送数据包         |
| `public void receive(DatagramPacket p)` | 使用数据包接收数据 |

- DatagramPacket：创建数据包

| 构造器签名                                                   | 说明                     |
| ------------------------------------------------------------ | ------------------------ |
| `public DatagramPacket(byte[] buf, int length, InetAddress address, int port)` | 创建发出去的数据包对象   |
| `public DatagramPacket(byte[] buf, int length)`              | 创建用来接收数据的数据包 |

- 一发一收
  - 客户端实现步骤
    - 创建DatagramSocket对象（客户端对象）
    - 创建DatagramPacket对象封装要发的数据（数据包对象）
    - 使用DatagramSocket对象的send方法，传入DatagramPacket对象
    - 释放资源
  - 服务端实现步骤
    - 创建DatagramSocket对象并指定端口（服务端对象）
    - 创建DatagramPacket对象接收数据（数据包对象）
    - 使用DatagramSocket对象的receive方法，传入DatagramPacket对象
    - 释放资源
- 多发多收
  - 客户端实现步骤
    - 创建DatagramSocket对象（客户端对象）
    - 使用while死循环不断的接受用户的数据输入，如果用户输入exit则退出程序
    - 如果用户输入的不是exit，把数据封装成DatagramPacket
    - 使用DatagramSocket对象的send方法，传入DatagramPacket对象
    - 释放资源
  - 服务端实现步骤
    - 创建DatagramSocket对象并指定端口（服务端对象）
    - 创建DatagramPacket对象接收数据（数据包对象）
    - 使用DatagramSocket对象的receive方法，传入DatagramPacket对象
    - 使用while死循环完成第三步

### TCP通信

- 面向连接，可靠通信
- `java.net.Socket类`和`java.net.ServerSocket类`实现TCP通信
- 客户端：
  - Socket
  - 创建客户端的Socket对象，请求与服务端的连接
  - 使用socket对象调用getOutputStream()方法得到字节输出流
  - 使用字节输出流完成数据的发送
  - 释放资源，关闭管道

| 构造器签名                             | 说明                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| `public Socket(String host, int port)` | 根据指定的服务器ip、端口号请求与服务端建立连接，连接通过，就获得了客户端socket |

| 方法签名                                | 说明               |
| --------------------------------------- | ------------------ |
| `public OutputStream getOutputStream()` | 获得字节输出流对象 |
| `public InputStream getInputStream()`   | 获得字节输入流对象 |

- 服务端：
  - ServerSocket
  - 创建ServerSocket对象，注册服务端端口
  - 调用ServerSocket对象的accpet()方法，等待客户端的连接，并得到Socket管道对象
  - 通过Socket对象调用getInputStream()方法得到字节输入流，完成数据的接收
  - 释放资源，关闭socket管道

| 构造器签名                      | 说明                 |
| ------------------------------- | -------------------- |
| `public ServerSocket(int port)` | 为服务端程序注册端口 |

| 方法签名                 | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| `public Socket accept()` | 阻塞等待客户端的连接请求，一旦与某个客户端成功连接，则返回服务端这边的Socket对象。 |

- 多发多收
  - 客户端死循环，让用户不断输入消息
  - 服务端也死循环，控制服务端程序收完消息后，继续接收下一个消息
  - 服务端只有一个线程，只能接收一个客户端的消息
- 同时接收多个客户端的消息
  - 主线程：负责接收客户端连接
  - 子线程：单独处理管道的消息
- B/S结构
  - `http://服务器IP:服务器端口`
  - 服务端：
    - 主线程负责接收浏览器连接
    - 子线程处理管道消息，返回一个网页数据
    - 服务器必须给浏览器响应HTTP协议规定的数据格式，否则浏览器不识别返回的数据
  - 因为http都是短连接，发送完网页资源就可以断开连接，并且高并发时容易宕机
    - 使用线程池优化
    - 把Socket管道包装成runnable对象

![image-20251017113912356](./images/image-20251017113912356.png)

```java
public class ServerDemo {
    public static void main(String[] args) throws Exception {
        System.out.println("===服务端启动===");
        // 目标：BS架构原理理解
        // 1.创建服务端ServerSocket对象，绑定端口号，监听客户端连接
        ServerSocket ss = new ServerSocket(8088);

        // 创建一个线程池
        ExecutorService pool = new ThreadPoolExecutor(3, 10, 10, TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(100), Executors.defaultThreadFactory(), new ThreadPoolExecutor.AbortPolicy());

        while(true){
            // 2.调用accept方法，阻塞等待客户端连接，一旦有客户端连接会返回一个Socket对象
            Socket socket = ss.accept();
            System.out.println("一个客户端连接了:" + socket.getInetAddress().getHostAddress());
            // 3.把这个客户端管道包装成一个任务交给线程池处理
            //new ServerReader(socket).start();
            pool.execute(new ServerReaderRunnable(socket));
        }
    }
}


public class ServerReaderRunnable implements Runnable{
    private Socket socket;

    public ServerReaderRunnable(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        // 读取消息
        try {
            // 给当前对应的浏览器管道响应一个网页数据回去
            OutputStream os = socket.getOutputStream();
            // 通过字节输出流包装写出去数据给浏览器
            // 把字节输出流包装成打印流
            PrintStream ps = new PrintStream(os);
            // 写响应的网页数据出去
            ps.println("HTTP/1.1 200 OK");
            ps.println("Content-Type:text/html;charset=utf-8");
            ps.println(); // 必须换行
            ps.println("<html>");
            ps.println("<head><title>服务器响应</title></head>");
            ps.println("<body>");
            ps.println("<h1 style='color:red;font-size=20px'>hello world</h1>");
            // 照片
            ps.println("<img src='http://www.itheima.com/images/logo.png'/>");
            ps.println("</body>");
            ps.println("</html>");
            ps.close();
            socket.close(); // http是短连接，发完网页数据可以关闭管道，再申请资源再开通

        } catch (Exception e) {
            // e.printStackTrace();
            System.out.println("客户端断开连接:" + socket.getInetAddress().getHostAddress());
        }
    }
}
```

## 常用API

### 时间获取

- LocalDate, LocalTime, LocalDateTime

```java
// jdk 8前
// 获取此刻时间 Date
Date d = new Date();
System.out.println(d);
// 格式化 SimpleDateFormat
SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss EEE a");
String str = sdf.format(d);

//jdk 8之后  LocalDateTime
LocalDateTime now = LocalDateTime.now();
now.getYear();
now.getDayOfYear();
// 格式化 DateTimeFormatter
DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss EEE a");
String str2 = dtf.format(now);
```

### BigDecimal

- 用于解决浮点型运算时，出现结果失真的问题，如double无法表示0.3
- 把小数包装成BigDecimal对象来运算
- 必须使用字符串构造器才能解决失真问题，double只能解决大数的运算
  - 也可以直接调用 `BigDecimal.valueOf(a)`

#### 构造器

| 构造器签名                      | 说明                                              |
| ------------------------------- | ------------------------------------------------- |
| `public BigDecimal(double val)` | 将 double 转换为 BigDecimal，注意：不推荐使用这个 |
| `public BigDecimal(String val)` | 把 String 转换成 BigDecimal                       |

#### 方法

| 方法签名                                                     | 说明                          |
| ------------------------------------------------------------ | ----------------------------- |
| `public static BigDecimal valueOf(double val)`               | 转换一个 double 成 BigDecimal |
| `public BigDecimal add(BigDecimal b)`                        | 加法                          |
| `public BigDecimal subtract(BigDecimal b)`                   | 减法                          |
| `public BigDecimal multiply(BigDecimal b)`                   | 乘法                          |
| `public BigDecimal divide(BigDecimal b)`                     | 除法                          |
| `public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode)` | 除法，可以控制精确到小数几位  |
| `public double doubleValue()`                                | 将 BigDecimal 转换为 double   |

# Java高级技术

## 单元测试

- 针对最小的功能单元：方法，编写测试代码对其进行正确性测试
- Junit单元测试框架
  - 对方法进行测试，第三方公司开源的
  - 优点
    - 可以灵活的编写测试代码，可以针对某个方法进行测试，也支持一键完成对全部方法的自动化测试，且各自独立
    - 不需要程序员分析测试的结果，会自动生成测试报告
  - 步骤
    - 导入jar包
    - 创建测试类，为每个方法编写测试方法（必须：公共、无参、无返回值）
    - 测试方法必须加`@Test`注解
    - 开始测试：选中测试方法，选择Juit运行，通过是绿色，失败是红色

## 反射

- 反射：加载类，并允许以编程的方式解剖类中的各种成分（成员变量、方法、构造器等）

- 反射第一步：加载类，获取类的字节码：Class对象

  - 获取Class对象的三种方式
    - `Class c1 = 类名.class`
    - 调用Class提供的方法：`public static Class forName(String package)`
    - Object提供的方法：`public Class getClass()`  `Class c3 = 对象.getClass()`

  ```java
  // 1.类名.class
  Class c1 = Student.class;
  System.out.println(c1);
  
  // 2.Class.forName("类全路径")
  Class c2 = Class.forName("com.wjk.reflect.Student");
  System.out.println(c2);
  
  // 3.对象.getClass()
  Student s = new Student();
  Class c3 = s.getClass();
  System.out.println(c3);
  System.out.println(c1 == c2); // true
  System.out.println(c1 == c3); // true
  ```

- 反射获取类中的成分并操作

  - 获取类的构造器：Constructor对象
  - 获取类的成员变量：Field对象
  - 获取类的成员方法：Method对象

  - **Class提供了从类中获取构造器的方法**

  | 方法                                                         | 说明                                     |
  | ------------------------------------------------------------ | ---------------------------------------- |
  | `Constructor<?>[] getConstructors()`                         | 获取全部构造器（只能获取public修饰的）   |
  | `Constructor<?>[] getDeclaredConstructors()`                 | 获取全部构造器（只要存在就能拿到）-常用  |
  | `Constructor<T> getConstructor(Class<?>... parameterTypes)`  | 获取某个构造器（只能获取public修饰的）   |
  | `Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes)` | 获取某个构造器（只要存在就能拿到）- 常用 |

  - **获取类构造器的作用：依然是初始化对象返回**

  | Constructor提供的方法                     | 说明                                                         |
  | ----------------------------------------- | ------------------------------------------------------------ |
  | `T newInstance(Object... initargs)`       | 调用此构造器对象表示的构造器，并传入参数，完成对象的初始化并返回 |
  | `public void setAccessible(boolean flag)` | 设置为true，表示禁止检查访问控制（暴力反射）                 |

  - 代码

  ```java
  public class ReflectDemo2 {
      @Test
      public void getClassInfo() {
          // 目标：获取类的信息，并对其进行操作
          // 1.反射第一步，获取class对象，代表拿到类
          Class c1 = Student.class;
          System.out.println(c1.getName()); // 类的全类名
          System.out.println(c1.getSimpleName()); // 类名
  
      }
  
      // 2.获取类的构造器对象并对其操作
      @Test
      public void getConstructorInfo() throws Exception {
          // 1.获取class对象
          Class c1 = Dog.class;
          // 2.获取构造器对象
          Constructor[] cons = c1.getDeclaredConstructors();
          for (Constructor c : cons) {
              System.out.println(c.getName() + "(" + c.getParameterCount() + ")");
          }
  
          // 3.获取单个构造器
          Constructor con = c1.getDeclaredConstructor();
          System.out.println(con.getName() + "(" + con.getParameterCount() + ")");
          Constructor con2 = c1.getDeclaredConstructor(String.class, int.class);
          System.out.println(con2.getName() + "(" + con2.getParameterCount() + ")");
  
          // 4.获取构造器的作用依然是创建对象
          // 暴力反射：暴力反射，可以访问private的构造器、属性和方法
          con.setAccessible(true);  // 绕过访问权限，直接访问
          Dog dog = (Dog) con.newInstance();
          System.out.println(dog);
  
          Dog dog2 = (Dog) con2.newInstance("小黄", 1);
          System.out.println(dog2);
      }
  
      // 3.获取类的成员变量对象并对其操作
      @Test
      public void getFieldInfo() throws Exception {
          // 获取class对象
          Class c1 = Dog.class;
          // 获取成员变量对象
          Field[] fields = c1.getDeclaredFields();
          for (Field f : fields) {
              System.out.println(f.getName() + "(" + f.getType().getName() + ")");
          }
  
          // 获取单个成员变量
          Field field = c1.getDeclaredField("hobby");
          System.out.println(field.getName() + "(" + field.getType().getName() + ")");
  
          Field field2 = c1.getDeclaredField("age");
          System.out.println(field2.getName() + "(" + field2.getType().getName() + ")");
  
          // 获取成员变量的作用依然是取值和赋值
          Dog d = new Dog("泰迪", 3);
          field.setAccessible(true); // 绕过访问权限，直接访问
          field.set(d, "社交");
          System.out.println(d);
  
          String hobby = (String) field.get(d);
          System.out.println(hobby);
      }
  
      // 4.获取类的成员方法对象并对其操作
      @Test
      public void getMethodInfo() throws Exception {
          // 获取class对象
          Class c1 = Dog.class;
          // 获取成员方法对象
          Method[] methods = c1.getDeclaredMethods();
          for (Method m : methods) {
              System.out.println(m.getName() + "(" + m.getParameterCount() + ")");
          }
          // 获取单个成员方法对象
          Method eat1 = c1.getDeclaredMethod("eat"); // 获取无参数的eat方法
          System.out.println(eat1.getName() + "(" + eat1.getParameterCount() + ")");
          Method eat2 = c1.getDeclaredMethod("eat", String.class);
          System.out.println(eat2.getName() + "(" + eat2.getParameterCount() + ")");
  
          // 获取成员方法的作用依然是调用方法
          Dog dog = new Dog("泰迪", 3);
          eat1.setAccessible(true);
          Object rs1 =  eat1.invoke(dog); // 唤醒对象dog的eat方法执行，相当于 d.eat()
          System.out.println(rs1); //null
  
          Object rs2 = eat2.invoke(dog, "牛肉"); // 唤醒对象dog的eat带参数的方法执行，相当于 d.eat("牛肉")
          System.out.println(rs2);
      }
  }
  ```

- 作用

  - 基本作用：可以得到一个类的全部成分然后操作
  - 可以破坏封装性（可以访问私有的构造器、成员变量、方法）
  - 可以绕过泛型的约束
  - **最重要的用途：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能**

## 注解

### 定义

- Java代码里的特殊标记，作用是让其他程序根据注解信息来决定怎么执行该程序

- 注解可以用在类上、构造器上、方法上、成员变量上、参数上等位置

- 自定义注解：自己定义注解

  - 定义方法
  - 特殊属性名：value
    - 如果注解中只有一个value属性，使用注解时，value名称可以不写

  ```java
  public @interface 注解名称{
  	public 属性类型 属性名() default 默认值;
  }
  
  // 自定义注解
  public @interface MyBook {
      String name();
      int age() default 18;
      String[] address();
  }
  
  public @interface A {
      String value();  // 特殊属性，在使用时如果只有一个value属性，则可以省略value
  }
  
  // 使用注解
  @MyBook(name = "zhangsan", age = 18, address = {"北京", "上海"})
  //@A(value = "delete")
  @A("delete")
  public class AnnotationDemo1 {
  }
  ```

- 原理

  - 注解本质上是一个接口，继承了Annotation接口，里面加了抽象方法
  - `@注解(...)`：其实就是一个实现类对象，实现了该注解以及Annotation接口

### 元注解

- 指的是注解 注解 的注解
- `@Target`：声明被修饰的注解只能在哪些位置使用
  - `@Target(ElementType.TYPE)`
  - TYPE-类、接口；FIELD-成员变量；METHOD-成员方法；
  - PARAMETER-方法参数；CONSTRUCTOR-构造器；LOCAL_VARIABLE-局部变量
- `@Retention` ：声明注解的保留周期
  - `@Retention(RetentionPolicy.RUNTIME)`
  - SOURCE：只作用在源码阶段，字节码文件中不存在
  - CLASS（默认值）：保留到字节码文件阶段，运行阶段不存在
  - RUNTIME（开发常用）：一直保留到运行阶段

```java
@Target({ElementType.METHOD, ElementType.FIELD}) // 指定注解作用范围为方法、成员变量
@Retention(RetentionPolicy.RUNTIME)
public @interface MyTest1 {

}
```

### 注解的解析

- 判断类、方法、成员变量上是否存在注解，并把注解里的内容给解析出来
- 指导思想：要解析谁的注解，就先拿到谁
  - 如解析类的注解，就应该先获取类的Class文件
  - Class、Method、Field、Constructor都实现了AnnotatedElement接口，它们都有解析注解的能力
  - `getDeclaredAnntations()`、`getDeclaredAnntation()`、`isAnnotationPresent()`

```java
public class AnnotationDemo3 {
    // 目标：解析注解
    @Test
    public void parseClass(){
        // 1.获取class对象
        Class c1 = Demo.class;
        // 2.判断这个类上是否陈列了注解MyTest2
        if(c1.isAnnotationPresent(MyTest2.class)){
            // 3.获取注解对象
            MyTest2 myTest2 = (MyTest2) c1.getDeclaredAnnotation(MyTest2.class);

            // 4.获取注解的属性值
            String[] address = myTest2.address();
            double height = myTest2.height();
            String value = myTest2.value();

            // 5.打印属性值
            System.out.println(Arrays.toString(address));
            System.out.println(height);
            System.out.println(value);
        }
    }

    @Test
    public void parseMethod() throws NoSuchMethodException {
        // 1.获取class对象
        Class c1 = Demo.class;
        // 2.获取方法对象
        Method method = c1.getDeclaredMethod("go");
        // 3.判断这个方法上是否有注解MyTest2
        if(method.isAnnotationPresent(MyTest2.class)){
            // 4.获取注解对象
            MyTest2 myTest2 = method.getDeclaredAnnotation(MyTest2.class);

            // 5.获取注解的属性值
            String[] address = myTest2.address();
            double height = myTest2.height();
            String value = myTest2.value();

            // 6.打印属性值
            System.out.println(Arrays.toString(address));
            System.out.println(height);
            System.out.println(value);
        }
    }
}
```

### 作用和应用场景

- 作用：让其他程序根据注解信息来决定怎么执行该程序
- 应用场景：如Juit框架

## 动态代理

- 为java对象创建代理对象

  - java.lang.reflect.Proxy类：提供了为对象产生代理对象的方法
  - `public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)`
    - 参数一：指定用哪个类加载器，去加载生成的代理类
    - 参数二：指定代理类需要实现的接口
    - 参数三：用来指定生成的代理对象要干什么事情

  ```java
  // 明星行为接口
  public interface StarService {
      void sing(String name);
      String dance();
  }
  
  // 实现接口
  public class Star implements StarService {
      private String name;
  
      @Override
      public void sing(String name) {
          System.out.println(this.name + "正在唱：" + name);
      }
  
      @Override
      public String dance() {
          System.out.println(this.name + "正在跳舞");
          return "谢谢！谢谢！";
      }
  }
  ```

  ```java
  // 代理工具类，负责创建代理对象并返回被使用
  public class ProxyUtil {
      // 创建一个代理对象返回
      public static StarService createProxy(Star s){
          /**
           * 参数一：指定用哪个类加载器，去加载生成的代理类
           * 参数二：指定代理对象要代理的接口
           * 参数三：用来指定生成的代理对象要干什么事情
           */
          StarService proxy = (StarService) Proxy.newProxyInstance(
                  ProxyUtil.class.getClassLoader(),
                  s.getClass().getInterfaces(),
                  new InvocationHandler() {
                      @Override
                      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                          // 声明代理对象要干的事情
                          // 参数一：proxy接收到代理对象本身（暂时用处不大）
                          // 参数二：method是正在被代理的方法
                          // 参数三：args是正在被代理的方法的参数
                          String methodName = method.getName();
                          if("sing".equals(methodName)){
                              System.out.println("准备话筒，收钱20万");
                          }else if("dance".equals(methodName)){
                              System.out.println("准备场地，收钱30万");
                          }
                          // 找真正的对象执行被代理的方法 method方法
                          Object result = method.invoke(s, args);
                          return result;
                      }
                  }
          );
          return proxy;
      }
  }
  ```

  ```java
  // 目标：创建代理对象
  // 1.创建被代理对象
  Star star = new Star("章若楠");
  // 2.创建一个专属于它的代理对象
  StarService proxy = ProxyUtil.createProxy(star);
  proxy.sing("小苹果");
  System.out.println(proxy.dance());
  ```

- 应用场景

  ```java
  public class ProxyUtil {
      public static <T> T createProxy(T obj) {
          T proxy = (T) Proxy.newProxyInstance(
                  ProxyUtil.class.getClassLoader(),
                  obj.getClass().getInterfaces(),
                  new InvocationHandler() {
                      @Override
                      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                          long start = System.currentTimeMillis();
                          Object result = method.invoke(obj, args);
                          long end = System.currentTimeMillis();
                          System.out.println( method.getName() + "方法耗时：" + (end - start) / 1000.0 + "s");
                          return result;
                      }
                  }
          );
          return proxy;
      }
  }
  ```

  
