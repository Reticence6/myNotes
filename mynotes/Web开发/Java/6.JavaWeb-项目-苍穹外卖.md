# 软件开发

## 软件开发流程

1. 需求分析
   - 需求规格说明书
   - 产品原型
2. 设计
   - UI设计
   - 数据库设计
   - 接口设计
3. 编码
   - 项目代码
   - 单元测试
4. 测试
   - 测试用例
   - 测试报告
5. 上线运维
   - 软件环境安装、配置

## 角色分工

项目经理，产品经理

UI设计师，架构师

开发工程师

测试工程师

运维工程师

## 软件环境

- 开发环境
- 测试环境
- 生产环境

## 技术选型

![image-20251224195135981](./images/image-20251224195135981.png)

## 后端实体类

- Entity：实体，通常和数据库中的表对应
- DTO：数据传输对象，通常用于程序中各层之间传递数据
- VO：视图对象，为前端展示数据提供的对象
- POJO：普通Java对象，只有属性和对应的getter和setter

## Swagger

- 使用Swagger，按照它的规范去定义接口及接口相关信息，就可以做到生成接口文档，以及在线接口调试页面

- Knife4j是Java MVC框架集成Swagger生成Api文档的增强解决方案

- 步骤

  - 倒入依赖

  ```xml
  <dependency>
     <groupId>com.github.xiaoymin</groupId>
     <artifactId>knife4j-spring-boot-starter</artifactId>
  </dependency>
  ```

  - 配置中加入相关配置   WebMvcConfiguration.java

  ```java
  /**
       * 通过knife4j生成接口文档
       * @return
  */
  @Bean
  public Docket docket() {
      ApiInfo apiInfo = new ApiInfoBuilder()
              .title("苍穹外卖项目接口文档")
              .version("2.0")
              .description("苍穹外卖项目接口文档")
              .build();
      Docket docket = new Docket(DocumentationType.SWAGGER_2)
              .apiInfo(apiInfo)
              .select()
        			// 指定生成接口需要扫描的包
              .apis(RequestHandlerSelectors.basePackage("com.sky.controller"))
              .paths(PathSelectors.any())
              .build();
      return docket;
  }
  ```

  - 设置静态资源映射，否则接口文档页面无法访问  WebMvcConfiguration.java

  ```java
  /**
       * 设置静态资源映射
       * @param registry
  */
  protected void addResourceHandlers(ResourceHandlerRegistry registry) {
          registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
          registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
  }
  ```

- 常用注解

  | **注解**          | **说明**                                                     |
  | ----------------- | ------------------------------------------------------------ |
  | @Api              | 用在类上，例如Controller，表示对类的说明  （tags）           |
  | @ApiModel         | 用在类上，例如entity、DTO、VO   （description）              |
  | @ApiModelProperty | 用在属性上，描述属性信息                                     |
  | @ApiOperation     | 用在方法上，例如Controller的方法，说明方法的用途、作用 （value） |


# 完善功能

## 密码加密存储

- 将密码加密后存储，提高安全性，使用MD5加密方式对明文密码加密

- 修改数据库明文密码，改为加密后的密文

- 修改java代码

  ```java
  // 对前端传过来的密码进行MD5加密处理
  password = DigestUtils.md5DigestAsHex(password.getBytes());
  if (!password.equals(employee.getPassword())) {
      //密码错误
      throw new PasswordErrorException(MessageConstant.PASSWORD_ERROR);
  }
  ```

## 日期格式转换

- 方法一：在属性前使用注解

  ```java
  //@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
  private LocalDateTime createTime;
  ```

- 方法二：扩展SpringMVC的消息转换器

  - JacksonObjectMapper.java 

  ```java
  /**
   * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
   * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
   * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
   */
  public class JacksonObjectMapper extends ObjectMapper {
  
      public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
      //public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
      public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm";
      public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";
  
      public JacksonObjectMapper() {
          super();
          //收到未知属性时不报异常
          this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);
  
          //反序列化时，属性不存在的兼容处理
          this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
  
          SimpleModule simpleModule = new SimpleModule()
                  .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                  .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                  .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
                  .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                  .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                  .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
  
          //注册功能模块 例如，可以添加自定义序列化器和反序列化器
          this.registerModule(simpleModule);
      }
  }
  ```

  - 修改 WebMvcConfiguration.java

  ```java
  protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
      log.info("扩展消息转换器...");
      // 创建一个消息转换器对象
      MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
      // 需要为消息转换器设置一个对象转换器，可以将Java对象序列化为Json数据
      converter.setObjectMapper(new JacksonObjectMapper());
      // 将自己的消息转换器加入容器中
      converters.add(0, converter);
  }
  ```

## 公共字段自动填充

- 业务表中的公共字段：create_time, create_user, update_time, update_user

- 实现思路

  - 自定义注解AutoFill，用于标识需要进行公共字段自动填充的方法

  ```java
  @Target(ElementType.METHOD)
  @Retention(RetentionPolicy.RUNTIME)
  public @interface AutoFill {
      // 数据库操作类型 update, insert
      OperationType value();
  }
  ```

  - 自定义切面类AutoFillAspect，统一拦截加入了AutoFill注解的方法，通过反射为公共字段赋值
  - 在Mapper的方法上加入AutoFill注解

# Redis

## 简介

- 基于**内存**的key-value结构数据库
- 特点
  - 基于内存存储，读写性能高
  - 适合存储热点数据（热点商品、资讯、新闻）
  - 企业应用广泛

## Redis数据类型

Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型

- 字符串(string)：普通字符串，Redis中最简单的数据类型
- 哈希(hash)：也叫散列，类似于Java中的HashMap结构，比如可以存储对象
- 列表(list)：按照插入顺序排序，可以有重复元素，类似于Java中的LinkedList，比如可以存储朋友圈点赞数据
- 集合(set)：无序集合，没有重复元素，类似于Java中的HashSet，比如可以运算共同朋友（交集）
- 有序集合(sorted set/zset)：集合中每个元素关联一个分数(score)，根据分数升序排序，没有重复元素，比如可以存储各种排行榜

<img src="./images/image-20221130190150749.png" alt="image-20221130190150749" style="zoom:50%;" />

## Redis常用命令

### 字符串操作命令

Redis 中字符串类型常用命令：

- **SET** key value 			     设置指定key的值
- **GET** key                                        获取指定key的值
- **SETEX** key seconds value         设置指定key的值，并将 key 的过期时间设为 seconds 秒（如保存验证码）
- **SETNX** key value                        只有在 key    不存在时设置 key 的值（如分布式锁）

### 哈希操作命令

Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：

- **HSET** key field value             将哈希表 key 中的字段 field 的值设为 value
- **HGET** key field                       获取存储在哈希表中指定字段的值
- **HDEL** key field                       删除存储在哈希表中的指定字段
- **HKEYS** key                              获取哈希表中所有字段
- **HVALS** key                              获取哈希表中所有值

### 列表操作命令

Redis 列表是简单的字符串列表，按照插入顺序排序，常用命令：

- **LPUSH** key value1 [value2]         将一个或多个值插入到列表头部
- **LRANGE** key start stop                获取列表指定范围内的元素
- **RPOP** key                                       移除并获取列表最后一个元素
- **LLEN** key                                        获取列表长度
- **BRPOP** key1 [key2 ] timeout       移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超    时或发现可弹出元素为止

### 集合操作命令

Redis set 是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，常用命令：

- **SADD** key member1 [member2]            向集合添加一个或多个成员
- **SMEMBERS** key                                         返回集合中的所有成员
- **SCARD** key                                                  获取集合的成员数
- **SINTER** key1 [key2]                                   返回给定所有集合的交集
- **SUNION** key1 [key2]                                 返回所有给定集合的并集
- **SREM** key member1 [member2]            移除集合中一个或多个成员

### 有序集合操作命令

Redis有序集合是string类型元素的集合，且不允许有重复成员。每个元素都会关联一个double类型的分数。常用命令：

常用命令：

- **ZADD** key score1 member1 [score2 member2]     向有序集合添加一个或多个成员
- **ZRANGE** key start stop [WITHSCORES]                     通过索引区间返回有序集合中指定区间内的成员
- **ZINCRBY** key increment member                              有序集合中对指定成员的分数加上增量 increment
- **ZREM** key member [member ...]                                移除有序集合中的一个或多个成员

### 通用命令

Redis的通用命令是不分数据类型的，都可以使用的命令：

- KEYS pattern 		查找所有符合给定模式( pattern)的 key 
- EXISTS key 		    检查给定 key 是否存在
- TYPE key 		       返回 key 所储存的值的类型
- DEL key 		         该命令用于在 key 存在时删除 key

## 在Java中操作Redis

### Redis的Java客户端

Redis 的 Java 客户端很多，常用的几种：

- Jedis
- Lettuce：性能高
- Spring Data Redis：Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，在Spring Boot项目中还提供了对应的Starter，即 spring-boot-starter-data-redis。

### Spring Data Redis

- 操作步骤：

  - 导入Spring Data Redis的Maven坐标

  ```xml
  <dependency>
  	<groupId>org.springframework.boot</groupId>
  	<artifactId>spring-boot-starter-data-redis</artifactId>
  </dependency>
  ```

  - 配置Redis数据源 application.yml
    - database:指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。
    - 可以通过修改Redis配置文件来指定数据库的数量

  ```yml
  sky:
    redis:
      host: localhost
      port: 6379
      password: 123456
      database: 1
  ```

  - 在application.yml中添加读取application-dev.yml中的相关Redis配置

  ```yml
  spring:
    profiles:
      active: dev
    redis:
      host: ${sky.redis.host}
      port: ${sky.redis.port}
      password: ${sky.redis.password}
      database: ${sky.redis.database}
  ```

  - 编写配置类，创建RedisTemplate对象
    - 当前配置类不是必须的，因为 Spring Boot 框架会自动装配 RedisTemplate 对象，但是默认的key序列化器为JdkSerializationRedisSerializer，导致我们存到Redis中后的数据和原始数据有差别，故设置为StringRedisSerializer序列化器。


  ```java
  @Configuration
  @Slf4j
  public class RedisConfiguration {
  
      @Bean
      public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){
          log.info("开始创建redis模版对象...");
          RedisTemplate redisTemplate = new RedisTemplate();
          // 设置redis的连接工厂对象
          redisTemplate.setConnectionFactory(redisConnectionFactory);
          // 设置redis key的序列化器
          redisTemplate.setKeySerializer(new StringRedisSerializer());
          return redisTemplate;
      }
  }
  ```

  - 通过RedisTemplate对象操作Redis

  ```java
  @SpringBootTest
  public class SpringDataRedisTest {
      @Autowired
      private RedisTemplate redisTemplate;
  
      @Test
      public void testRedisTemplate(){
          System.out.println(redisTemplate);
          //string数据操作
          ValueOperations valueOperations = redisTemplate.opsForValue();
          //hash类型的数据操作
          HashOperations hashOperations = redisTemplate.opsForHash();
          //list类型的数据操作
          ListOperations listOperations = redisTemplate.opsForList();
          //set类型数据操作
          SetOperations setOperations = redisTemplate.opsForSet();
          //zset类型数据操作
          ZSetOperations zSetOperations = redisTemplate.opsForZSet();
      }
  }
  ```

**操作字符串类型数据**

```java
@Test
public void testString(){
    // set get setex setnx
    redisTemplate.opsForValue().set("city", "北京");
    String city = (String) redisTemplate.opsForValue().get("city");
    System.out.println(city);

    redisTemplate.opsForValue().set("code", "12345", 3, TimeUnit.MINUTES);

    redisTemplate.opsForValue().setIfAbsent("lock", "1");
    redisTemplate.opsForValue().setIfAbsent("lock", "2");
}
```

**操作哈希类型数据**

```java
@Test
public void testHash(){
    // hset hget hdel hkeys hvals
    HashOperations hashOperations = redisTemplate.opsForHash();

    hashOperations.put("100", "name", "tom");
    hashOperations.put("100", "age", "20");

    String name = (String) hashOperations.get("100", "name");
    System.out.println(name);

    Set keys = hashOperations.keys("100");
    System.out.println(keys);
    List values = hashOperations.values("100");
    System.out.println(values);

    hashOperations.delete("100", "age");
}
```

**操作列表类型数据**

```java
@Test
public void testList(){
    //lpush lrange rpop llen
    ListOperations listOperations = redisTemplate.opsForList();

    listOperations.leftPushAll("mylist","a","b","c");
    listOperations.leftPush("mylist","d");

    List mylist = listOperations.range("mylist", 0, -1);
    System.out.println(mylist);

    listOperations.rightPop("mylist");

    Long size = listOperations.size("mylist");
    System.out.println(size);
}
```

**操作集合类型数据**

```java
/**
 * 操作集合类型的数据
 */
@Test
public void testSet(){
    //sadd smembers scard sinter sunion srem
    SetOperations setOperations = redisTemplate.opsForSet();

    setOperations.add("set1","a","b","c","d");
    setOperations.add("set2","a","b","x","y");

    Set members = setOperations.members("set1");
    System.out.println(members);

    Long size = setOperations.size("set1");
    System.out.println(size);

    Set intersect = setOperations.intersect("set1", "set2");
    System.out.println(intersect);

    Set union = setOperations.union("set1", "set2");
    System.out.println(union);

    setOperations.remove("set1","a","b");
}
```

**操作有序集合类型数据**

```java
/**
 * 操作有序集合类型的数据
 */
@Test
public void testZset(){
    //zadd zrange zincrby zrem
    ZSetOperations zSetOperations = redisTemplate.opsForZSet();

    zSetOperations.add("zset1","a",10);
    zSetOperations.add("zset1","b",12);
    zSetOperations.add("zset1","c",9);

    Set zset1 = zSetOperations.range("zset1", 0, -1);
    System.out.println(zset1);

    zSetOperations.incrementScore("zset1","c",10);

    zSetOperations.remove("zset1","a","b");
}
```

**通用命令操作**

```java
/**
 * 通用命令操作
 */
@Test
public void testCommon(){
    //keys exists type del
    Set keys = redisTemplate.keys("*");
    System.out.println(keys);

    Boolean name = redisTemplate.hasKey("name");
    Boolean set1 = redisTemplate.hasKey("set1");

    for (Object key : keys) {
        DataType type = redisTemplate.type(key);
        System.out.println(type.name());
    }

    redisTemplate.delete("mylist");
}
```

## 店铺营业状态设置

```java
public class ShopController {

    public static final String KEY = "SHOP_STATUS";

    @Autowired
    private RedisTemplate redisTemplate;

    /**
     * 设置店铺的营业状态
     * @param status
     * @return
     */
    @PutMapping("/{status}")
    @ApiOperation("设置店铺的营业状态")
    public Result setStatus(@PathVariable Integer status){
        log.info("设置店铺的营业状态为: {}", status == 1 ? "营业中" : "打烊中");
        redisTemplate.opsForValue().set(KEY, status);
        return Result.success();
    }

    /**
     * 获取店铺的营业状态
     * @return
     */
    @GetMapping("/status")
    @ApiOperation("获取店铺的营业状态")
    public Result<Integer> getStatus(){
        Integer status = (Integer) redisTemplate.opsForValue().get(KEY);
        log.info("管理端获取店铺的营业状态为: {}", status == 1 ? "营业中" : "打烊中");
        return Result.success(status);
    }
}
```

# HttpClient

## 介绍

- HttpClient 是Apache Jakarta Common 下的子项目，可以用来提供高效的、最新的、功能丰富的支持 HTTP 协议的**客户端编程工具包**，并且它支持 HTTP 协议最新的版本和建议。
- **HttpClient作用：**
  - 发送HTTP请求
  - 接收响应数据
- **HttpClient应用场景：**当我们在使用扫描支付、查看地图、获取验证码、查看天气等功能时，其实，应用程序本身并未实现这些功能，都是在应用程序里访问提供这些功能的服务，访问这些服务需要发送HTTP请求，并且接收响应数据，可通过HttpClient来实现。
- **HttpClient的核心API：**
  - HttpClient：Http客户端对象类型，使用该类型对象可发起Http请求。
  - HttpClients：可认为是构建器，可创建HttpClient对象。
  - CloseableHttpClient：实现类，实现了HttpClient接口。
  - HttpGet：Get方式请求类型。
  - HttpPost：Post方式请求类型。
- **HttpClient发送请求步骤：**
  - 创建HttpClient对象
  - 创建Http请求对象
  - 调用HttpClient的execute方法发送请求

## 使用方式

### Maven

HttpClient的maven坐标

```xml
<dependency>
	<groupId>org.apache.httpcomponents</groupId>
	<artifactId>httpclient</artifactId>
	<version>4.5.13</version>
</dependency>
```

但是在项目中，导入的aliyun oss中已经导入了HttpClient，所以不导入也可以使用

```xml
<dependency>
    <groupId>com.aliyun.oss</groupId>
    <artifactId>aliyun-sdk-oss</artifactId>
</dependency>
```

### 发送GET请求

```java
@Test
public void testGET() throws Exception {
    // 创建httpClient对象
    CloseableHttpClient httpClient = HttpClients.createDefault();

    // 创建请求对象
    HttpGet httpGet = new HttpGet("http://localhost:8080/user/shop/status");

    // 发送请求, 接受响应结果
    CloseableHttpResponse response = httpClient.execute(httpGet);

    // 获取服务端返回的状态码
    int statusCode = response.getStatusLine().getStatusCode();
    System.out.println("服务端返回的状态码为：" + statusCode);

    HttpEntity entity = response.getEntity();
    String body = EntityUtils.toString(entity);
    System.out.println("服务端返回的数据为：" + body);

    // 关闭资源
    response.close();
    httpClient.close();
}
```

### 发送POST请求

```java
@Test
public void testPOST() throws Exception {
    // 创建httpClient对象
    CloseableHttpClient httpClient = HttpClients.createDefault();

    // 创建请求对象
    HttpPost httpPost = new HttpPost("http://localhost:8080/admin/employee/login");

    JSONObject jsonObject = new JSONObject();
    jsonObject.put("username", "admin");
    jsonObject.put("password", "123456");

    StringEntity entity = new StringEntity(jsonObject.toString());
    // 指定编码方式
    entity.setContentEncoding("utf-8");
    // 指定数据格式
    entity.setContentType("application/json");
    httpPost.setEntity(entity);

    // 发送请求
    CloseableHttpResponse response = httpClient.execute(httpPost);

    // 解析返回结果
    int statusCode = response.getStatusLine().getStatusCode();
    System.out.println("响应码为：" + statusCode);

    HttpEntity entity1 = response.getEntity();
    String body = EntityUtils.toString(entity1);
    System.out.println("响应数据为：" + body);

    // 关闭资源
    response.close();
    httpClient.close();
}
```

# 微信小程序

## 目录结构

小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：

- **app.js：**必须存在，主要存放小程序的逻辑代码

- **app.json：**必须存在，小程序配置文件，主要存放小程序的公共配置

- **app.wxss:**  非必须存在，主要存放小程序公共样式表，类似于前端的CSS样式

对小程序主体三个文件了解后，其实一个小程序又有多个页面。这些页面会存放在pages目录：

- **js文件：**必须存在，存放页面业务逻辑代码，编写的js代码。
- **wxml文件：**必须存在，存放页面结构，主要是做页面布局，页面效果展示的，类似于HTML页面。
- **json文件：**非必须，存放页面相关的配置。
- **wxss文件：**非必须，存放页面样式表，相当于CSS文件。
